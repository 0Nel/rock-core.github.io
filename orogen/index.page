---
title: The basics
sort_info: 0
--- name:content pipeline:tags,markdown,blocks

This part will introduce you with the basics of component definition and
implementation using oroGen. First, we present the Orocos RealTime Toolkit (RTT)
which provides the execution layer used in oroGen projects. Then, we go in more
details on how to use oroGen and present some of the basic functionalities. More
specific information is available in the rest of the guide.

An overview of the Orocos RealTime Toolkit (RTT)
------------------------------------------------

The Orocos RealTime Toolkit is a C++ library that allow to build and execute
component-oriented layers. The goal of such an approach is to make each
component as independent to the other components as possible. One benefit is
code reusability: a given component can be used in two completely different
systems. Another less advertised one is robustness: a component can validate its
inputs and assess its own state without having to care about the rest of the
other components.

Definition and implementation of RTT components
-----------------------------------------------

To *define* an Orocos component (called a _task context_), one must:

 * define an interface, i.e. all the means of communication that exist with this
   component
 * implement the actual component functionality

At the C++ level, a component is a subclass of the <tt>RTT::TaskContext</tt>
class. This class provides all the base services needed to plug your code into
Orocos' execution engine.

On the one side, the component's interface is split into three parts:

 * the _configuration interface_, allows to set up the component's parameters
   before it is started. This is done through _properties_. This is for instance
   the specification of a device file for a driver. The corresponding RTT class
   is <tt>RTT::Property</tt>.
 * the _data flow_ transports the runtime data from one component to another.
   This is done through the listing of input and output ports. The corresponding
   RTT class is <tt>RTT::InputPort</tt> and <tt>RTT::OutputPort</tt>.
 * the _control flow_ allows to change the component's behaviour. This is done
   through _methods_ and _commands_. The corresponding RTT classes are
   <tt>RTT::Method</tt> and <tt>RTT::Command</tt>.

On the other side, Orocos components offers a state machine. The component's
functionality is split into C++ methods, each of them being called for one of
the state machine transitions. By default, these methods will do nothing, but
you will be able to reimplement them to hook the desired functionality in your
components.

Deployment
----------
What we saw above is how to define a component: how we can communicate with it
(the interface), and how it offers an execution model (the state machine)
allowing to integrate its functionality.

To transform this definition into a running system, one must define a few more
things:

 * in which condition(s) and in what thread context the component's
   functionality should be called. This includes putting components in separated
   processes so that one crashing does not affect others.
 * how to configure, i.e. their properties should be set to values valid for the
   current platform.
 * the data flow between the components needs to be created.

In the RTT, that step is called the _deployment_. While the last two points is
quite common in modular architectures, the ability to associate _at deployment
time_ a component with a thread/process and a triggering mechanism is quite
unique to Orocos/RTT.

What is oroGen ?
----------------

oroGen is a tool that automates the definition and creation of task contexts,
and of deployments. More specifically, it allows the following:

 * define one or many task context interfaces. oroGen creates a certain number of
   C++ classes that match the task context definitions.
 * define one or many deployments. Deployments in oroGen are usually only used
   to create binaries in which task contexts are instanciated and associated to
   activities (threads and triggers). oroGen also allows to pre-wire, i.e. add
   connections between the task ports, but it is preferred to use a dynamic
   method for that (like CORBA for instance).

Orogen projects
---------------
To use orogen, one needs to write a project file. This project file usually ends
with .orogen. It is in fact Ruby code, but you don't need to know Ruby to write
one.

Each orogen project allows to define:
 - one or many task contexts
 - one or many deployments

Moreover, orogen will handle automatically the marshalling/unmarshalling of
the data types you use in your projects. For instance, it will handle the
transport over CORBA when required.

Basic orogen file
-----------------
One needs to give a name to the orogen project, and optionally a version

{coderay:: ruby}
name 'example'
version '0.1'
{coderay}

The project is then generated with
  
orogen example.orogen
{: .commandline}

or, if corba support is required
  
orogen \-\-corba example.orogen
{: .commandline}

The generated code is a CMake package. In it, files are sorted into three places:

 * the .orogen/ directory under which are files that should not be touched by
   the component's developer. Any change to those files would be erased at
   the next component generation.
 * the templates/ directory in which orogen puts freshly generated files. 
 * the user part, which are files that are meant to be modified by the component's
   developer. These files will never be touched again by orogen: orogen will
   limit itself to generate the missing ones (as for instance new task context
   definitions).
   
In some cases, modifications to the orogen project will require some modifications to
the user part as well. In that case, you will have to copy/paste the corresponding
code from the templates/ files. These cases will be detailed in this guide.

Once the project is generated, you can compile it as any CMake-based package.

mkdir build<br />
cmake -DCMAKE_INSTALL_PREFIX=/installation/directory ..<br />
make
{: .commandline}

and the regeneration can be triggered with

make regen
{: .commandline}

Defining types
--------------
To allow, at runtime, to properly handle the input and output of Orocos
components, one must first declare what types are to be used in the component's
interface. Using Orogen, only the type description is required. Orogen then
takes care of integrating those types in the RTT.

The type definitions are done in a subset of C/C++. The following limitations
apply:
 * orogen understands basic C types, types defined with stdint.h (uint8_t,
   int64_t, ...), structs and enums.
 * all types must be so-called "value types": no virtual methods and no
   inheritance
 * namespaces are recognized as well
 * std::vector<> can be used, but must be referred to as std::vector<>, not
   vector<>.
 * 'std::string' can be used directly (i.e. directly as a method/command
   argument or as a port type for instance), but cannot be used in a struct or
   vector

So, for instance, a valid type definition file named <tt>exampleTypes.h</tt>
would be:
{coderay:: cpp}
namespace example
{
    struct Time
    {
        uint64_t microseconds;
    };
    struct Values
    {
        Time timestamp;
        std::vector<double> values;
    };
}
{coderay}

that can be loaded in the orogen file with the following statement:
{coderay:: ruby}
import_types_from 'exampleTypes.h'
{coderay}

If you change the type definition files, you <b>must</b> regenerate the project,
either by calling the orogen tool directly or by using the 'make regen' command.
Orogen will try to regenerate by himself if a change is detected, but this is
still an experimental feature.

We will see in the suite of this guide where the type definitions are used. In
all those places, though, the types must be referred to by their fullname. The
library used for type handling in orogen uses '/' as a namespace marker, so one
will have to write <tt>/example/Time</tt> to refer to <tt>example::Time</tt>

More advanced topics are covered later in this guide. It includes:
 * adding methods to the type definitions
 * using types that orogen cannot understand
 * using smart pointers

Task Contexts
-------------

A new task context model is defined with

{coderay:: ruby}
task_context "ClassName" do
  
end
{coderay}

This generates a task context class named <tt>project_name::ClassName</tt> in
<tt>tasks/ClassName.cpp</tt> and <tt>tasks/ClassName.hpp</tt>. In general, you
will only need to implement the state hooks, commands and methods. The
definition of the task interface (methods, commands, ports and properties) is
part of the orogen task definition.

The definition of the task interface, and the corresponding usage in hooks, is
covered later in this guide.

Deployments
-----------
In orogen, a deployment is one single executable file in which a certain set of task
contexts have been instanciated into tasks, and associated to both threads and
triggering mechanisms.

The deployment is defined with

{coderay:: ruby}
deployment "deployment_name" do

end
{coderay}

Deployments are also detailed later in this guide.


