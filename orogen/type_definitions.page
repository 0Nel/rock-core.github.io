---
title: Type definitions
sort_info: 50
--- name:content pipeline:tags,markdown,blocks
One of the first thing that a component designer has to think about is defining the
data structures that will be used in the component's interfaces:

* in the communication between components (ports)
* in the configuration of the component (properties)
* in the control of the component (methods and commands).

From your component definitions, oroGen will generate the necessary RTT plugins
to support:

* XML marshalling as .xml or .cpf
* CORBA marshalling to use with the CORBA transport
* Typelib marshalling to use with orogen's logger
* transparent Ruby bindings thanks to the use of Typelib 

Type definitions
----------------
In oroGen, the types are described from a subset of C++:

* typedef, struct and enums
* std::vector is allowed
* namespaces are allowed

The purpose of defining all of this in C++ is that you, the component
developper, can use C++ constructs that oroGen does not support, provided they
are protected with the following guards:
{coderay:: c}
#ifndef __orogen
<unsupported features>
#endif
{coderay}

What _is_ allowed are:

* non-virtual methods
* access limiters (public, protected, private)

What is _completely forbidden are_:

* virtual methods
* adding attributes that are hidden to orogen
* the use of the 'class' keyword. Use 'struct', which in C++ is simply a class
  with a default visibility of public.

Example: defining a Time class

{coderay:: cpp}
namespace base {
  struct Time
  {
    uint64_t microseconds;
#ifndef __orogen
    static Time fromMilliseconds(uint64_t ms);
    Time operator +(Time const& other);
#endif
  };
}
{coderay}

Note that, for now, all types that are defined in the orogen project must be
defined inline: orogen does not support separating the implementation from the
definition. Types that are defined in separate libraries are fine, though.

Limitations due to the RTT itself
---------------------------------
Unfortunately, oroGen has to cope with RTT limited support for basic types (int,
long, ...), and therefore the following limitations apply:

 * char, short, 64 bit integers and float are forbidden as argument types for a
   method/command. Use int instead of char or short, and double instead of
   float. Unfortunately there is no equivalent for 64 bit integers.
 * structs that contain 64 bit integers won't be marshallable as XML.
 * there is no typelib marshalling - and hence no logging - for
   <tt>vector&lt;double&gt;</tt> used "as-is". <tt>vector&lt;double&gt;</tt> in a struct is fine though.

Defining types in an oroGen project
-----------------------------------
In an oroGen project, one adds one or many following statement to load a C/C++
file that defines the project's types:

{coderay:: ruby}
import_types_from "myproject.h"
{coderay}

At the load point, all types used by "myproject.h" must already be defined. So,
if you define type A in a.h and type B, that uses A, in b.h, you need to order
the imports as:

{coderay:: ruby}
import_types_from "a.h"
import_types_from "b.h"
{coderay}

The reverse order will not work.

The issue of loading types from other oroGen project is handled [in
here](cross_project.html)
