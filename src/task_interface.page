---
title: Task Interface
sort_info: 100
--- name:content pipeline:tags,markdown,blocks
We'll cover in this page how to define your task's interface. All statements
presented in this page are to be included in a task context definition, i.e.
between 'do' and 'end' in

{coderay:: ruby}
task_context "ClassName" do
   ...
end
{coderay}

The task interface is the focus of that page. Other issues, as using different
triggering modes and subclassing between task contexts is covered later.

Ports
-----
Ports are defined with

{coderay:: ruby}
input_port('in', 'my_type').
  doc('documentation string')
output_port('out', 'another_type').
  doc('documentation string')
{coderay}

Ports can be accessed in the C++ code with
{coderay:: cpp}
my_type sample;
if (_in.read(sample))
{
    // got a new sample, do something with it
}
another_type data = calculateData();
_out.write(data);
{coderay}

where, 'sample' and 'data' are of the same type than the corresponding ports.
Another operation of interest is the <tt>connected()</tt> predicate. It tests if
there is a data provider that will send data to input ports
(<tt>in.connected()</tt>) or if there is a listener component that will get the
samples written on output ports.

For instance,
{coderay:: cpp}
if (_out.connected())
{
    // generate the data for _out. This is useful if generating
    // the data is costly
    another_type data = calculateData();
    _out.write(data);
}
{coderay}

Properties
----------
Properties are defined with
{coderay:: ruby}
property('name', 'configuration_type').
    doc 'what this property is about'
{coderay}

And can be accessed in the code with

{coderay:: cpp}
configuration_type configuration_value = _name.get();
// Validate configuration_type, and change the value
_name.set(configuration_value)
{coderay}

Commands
--------
The basic interface is 

{coderay:: ruby}
command('commandName')
{coderay}

Then; one can declare arguments with

{coderay:: ruby}
command('commandName').
    arg('arg0', '/arg/type').
    arg('arg1', '/example/other_arg')
{coderay}
Note the dot at the end of the first two lines. This dot is important and, if
omitted, will lead to syntax errors.

In the generated task class, the command is implemented with two methods:
{coderay:: cpp}
bool commandName(arg::type const& arg0, example::other_arg const& arg1);
bool iscommandNameFinished(arg::type const& arg0, example::other_arg const& arg1);
{coderay}

The first method is called once when the command is received by the task
context, and should return true if the command is accepted, false otherwise. It
is called in the same thread than the component's state machine, so there should
be no multi-threading issues associated with it. In general, it will set a flag
so that the updateHook() handles the actual execution of the command.

Then, the <tt>iscommandNameFinished</tt> method is called each time a remote
component requires to know if the command is finished or not. It is *not* called
in the same thread than the rest of the component, so multi-threading should be
taken into account. It should return true if the command is finished, and false
otherwise.

We already mentionned that Orogen does not touch your C++ code in tasks/. So, if
you add a new command to your task definition, you will need to add the
corresponding methods to the C++ task implementation as well. To do this, you
can simply copy/paste them from the templates/tasks/ directory.

Methods
-------
Methods are defined in the same way than commands:

{coderay:: ruby}
method('commandName').
    arg('arg0', '/arg/type').
    arg('arg1', '/example/other_arg')
{coderay}

Additionally, a return type can be added with
{coderay:: ruby}
method('methodName').
    returns('int').
    arg('arg0', '/arg/type').
    arg('arg1', '/example/other_arg')
{coderay}

Note the dot at the end of all but the last line. This dot is important and,
if omitted, will lead to syntax errors.

In the generated task class, the method simply maps to a C++ method:
{coderay:: cpp}
return_type methodName(arg::type const& arg0, example::other_arg const& arg1);
{coderay}

the default return type is 'void'.

Methods, unlike commands, are synchronous from the point of view of the caller.
It means that the method is in general called in a thread different than the
component's thread. It should therefore take care of possible multi-threading
issues.

As for the commands, if you add a new method to your task definition, you will
need to add the corresponding method to the C++ task implementation as well. To
do this, you can simply copy/paste it from the corresponding .cpp and .hpp files
in templates/tasks/.

C++ objects representing the interface elements
-----------------------------------------------
For each element of the interface, Orogen declares the corresponding RTT C++
object as an attribute of the task implementation. The attribute's name is the
object name with an underscore prepended. For instance, the command declared
with
{coderay:: ruby}
command('commandName')
{coderay}

is mapped to an attribute named <tt>_commandName</tt>, of type
<tt>RTT::Command</tt>.

The mappings are as follows:
 * commands are RTT::Command
 * methods are RTT::Method
 * input ports are RTT::InputPort
 * output ports are RTT::OutputPort
 * properties are RTT::Property

Refer to the RTT's documentation to learn more on the operations available on
these objects.

