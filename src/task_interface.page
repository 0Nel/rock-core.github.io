---
title: Task Interface
sort_info: 100
--- name:content pipeline:tags,markdown,blocks
We'll cover in this page how to define your task's interface. All statements
presented in this page are to be included in a task context definition, i.e.
between 'do' and 'end' in

{coderay:: ruby}
task_context "ClassName" do
   ...
end
{coderay}

The task interface is the focus of that page. Other issues, as using different
triggering modes and subclassing between task contexts is covered later.

Ports
-----
Ports are defined with

{coderay:: ruby}
input_port('in', 'type').
  doc('documentation string')
output_port('out', 'type').
  doc('documentation string')
{coderay}

Ports can be accessed in the C++ code with
{coderay:: cpp}
if (_in.read(sample))
{
    // got a new sample, do something with it
}
_out.write(data);
{coderay}

where, 'sample' and 'data' are of the same type than the corresponding ports.
Another operation of interest is the <tt>connected()</tt> predicate. It tests if
there is a data provider that will send data to input ports
(<tt>in.connected()</tt>) or if there is a listener component that will get the
samples written on output ports.

Properties
----------
Properties are defined with
{coderay:: ruby}
property('name', 'type').
    doc 'what this property is about'
{coderay}

Commands
--------
{coderay:: ruby}
command('commandName')
{coderay}

To add arguments to the method, one does
{coderay:: ruby}
command('commandName').
    arg('arg0', '/arg/type').
    arg('arg1', '/example/other_arg')
{coderay}
Note the dot at the end of the first two lines. This dot is important and, if
omitted, will lead to syntax errors.

In the generated task class, the command is implemented with two methods:
{coderay:: cpp}
bool commandNameStart(arg::type const& arg0, example::other_arg const& arg1);
bool commandNameWorker(arg::type const& arg0, example::other_arg const& arg1);
{coderay}

The start method is called once when the command is received by the task
context, and should return true if the command is accepted, false otherwise. The
Worker method is called <b>in the same thread than the updateHook</b> each time
the updateHook is called. In other words, commands do not have any
multithreading issues with the task context's state machine.

We already mentionned that Orogen does not touch your C++ code in tasks/. So, if
you add a new command to your task definition, you will need to add the
corresponding methods to the C++ task implementation as well. To do this, you
can simply copy/paste them from the templates/tasks/ directory.

Methods
-------
Methods are defined in the same way than commands:

{coderay:: ruby}
method('commandName').
    arg('arg0', '/arg/type').
    arg('arg1', '/example/other_arg')
{coderay}

Additionally, a return type can be added with
{coderay:: ruby}
method('methodName').
    returns('int').
    arg('arg0', '/arg/type').
    arg('arg1', '/example/other_arg')
{coderay}

Note the dot at the end of all but the last line. This dot is important and,
if omitted, will lead to syntax errors.

In the generated task class, the method simply maps to a C++ method:
{coderay:: cpp}
return_type methodNae(arg::type const& arg0, example::other_arg const& arg1);
{coderay}

the default return type is 'void'.

As for the commands, if you add a new method to your task definition, you will
need to add the corresponding method to the C++ task implementation as well. To
do this, you can simply copy/paste it from the corresponding .cpp and .hpp files
in templates/tasks/.

C++ objects representing the interface elements
-----------------------------------------------
This is a more advanced topic. For each element of the interface, Orogen
declares the corresponding RTT C++ object as an attribute of the task
implementation. The attribute's name is the object name with an underscore
prepended. For instance, the command declared with
{coderay:: ruby}
command('commandName')
{coderay}

is mapped to an attribute named <tt>_commandName</tt>, of type
<tt>RTT::Method</tt>.

The mappings are as follows:
 * commands are RTT::Command
 * methods are RTT::Method
 * input ports are RTT::InputPort
 * output ports are RTT::OutputPort
 * properties are RTT::Property

Refer to the RTT's documentation to learn more on the operations available on
these objects.

