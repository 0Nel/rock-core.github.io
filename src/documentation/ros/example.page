---
title: Example
sort_info: 300
---

In this page, we will detail -- as an example -- how the ROS prosilica camera
output can be displayed using vizkit.

Step 1: Data Type Convertion
----------------------------
In this case, we want to be able to convert the ROS image message into its Rock
equivalent, the base::samples::frame::Frame type.

Since base::samples::frame::Frame is declared in the base/orogen/types oroGen
project, we go there and add the necessary ROS-to-Rock mapping declaration:

~~~ ruby
typekit.ros_mappings '/base/samples/frame/Frame' => 'sensor_msgs/Image'
~~~

And run amake once

~~~
amake
~~~

We then have to fill in the convertion functions. If there was no ROS mappings
in the package before, just edit typekit/ROSConvertions.cpp. Otherwise, we have
to copy the relevant signatures from templates/typekit/ROSConvertions.hpp and
.cpp into the corresponding files in the typekit/ subfolder.

Once the functions are filled in, simply build with

~~~
amake
~~~

Step 2: Runtime Setup
---------------------
At the setup level, getting hold on a topic is as simple as getting hold on a
port. For instance, the equivalent of the "rostopic echo" command would be:

~~~ ruby
require 'orocos'
Orocos.initialize
Orocos::ROS.initialize

topic = Orocos::ROS.topic ARGV.first
reader = topic.reader :type => :buffer, :size => 10
while true
  while value = reader.read_new
    pp value
    sleep 0.01
  end
end
~~~

Using the connection API as if it was a Rock component, one can then connect the
nodes to the task contexts. Assuming that we have one ROS-driven camera and one
Rock-driven one

~~~ ruby
require 'orocos'
Orocos.initialize
Orocos::ROS.initialize

Orocos.run 'camera_prosilica::Task' => 'right_camera', 'stereo::Task' => 'stereo' do
  left_camera  = Orocos::ROS.topic '/prosilica/frame_raw
  right_camera = Orocos.name_service.get 'right_camera'
  stereo       = Orocos.name_service.get 'stereo'
  right_camera.frame.connect_to stereo.right_frame
  left_camera.connect_to stereo.left_frame

  right_camera.configure
  stereo.configure
  right_camera.start
  stereo.start
  Orocos.watch(stereo, right_camera) # Cannot watch a ROS node
end
~~~

All the Orocos connection policies can be applied when connecting a ROS node
with a Rock component.

Step 3: using the Rock tooling
------------------------------
For the tooling to work, the orocos.rb library maps the ROS graph into a
structure that maps the Rock component structure. In other word, a given ROS
node will have "input ports" and "output ports". The former are the topics it is
subscribed to and the latter the topics that it is publishing.

One can get hold of a ROS node object through the standard name service
interface:

~~~ ruby
camera = Orocos.name_service.get '/camera_prosilica'
~~~

and give that to APIs that expect Orocos tasks:

~~~ ruby
require 'orocos'
Orocos.initialize
Orocos::ROS.initialize
camera = Orocos.name_service.get '/camera_prosilica'

require 'vizkit'
task_inspector = Vizkit.default_loader.TaskInspector
task_inspector.add camera
Vizkit.exec
~~~
