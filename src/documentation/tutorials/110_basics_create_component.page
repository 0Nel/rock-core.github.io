---
title: Creating components
sort_info: 110
---

Abstract
--------------

This tutorial will give you some hands-on experience on:

 * how to model an oroGen component and embed a library
 * how to run a component

If you don't want to execute the following steps by yourself, the result can also be found in '~dev/basics_tutorial'.
For this tutorial it is assumed that your autoproj installation can be found in ~/dev.

The component we want to create will **integrate** the functionality of the
library developed [in the previous tutorial](100_basics_create_library.html), exposing that functionality into a
system.

The final component will look like:

![Producer Component](110_producer_component.png)
{: .align-center}

This step-by-step tutorial will guide you through the process of:

 * creating the oroGen component package
 * declaring the component interface
 * adding the necessary C++ code for the component to pull data from the
   message\_driver library out to its output port.

Creating an oroGen component
--------------------------------
While Rock uses the Orocos Realtime Toolkit (Orocos RTT) to build its components upon, and uses the Orocos generation tool 'oroGen' to easily create so-called oroGen components. oroGen requires a component specification to generate a skeleton for you, which you can fill with the functionality you require.

There are multiple advantages for using oroGen:

 * one can get an overview of the components without having to look at the
   code, and without having to rely on up-to-date documentation
 * you have the guarantee that your component(s) will be usable across the
   complete Rock toolchain, from simple command-line execution to advanced
   model-based system management

This tutorial does not cover all details of Orocos components but you will find further information in the [oroGen documentation](/documentation/orogen/index.html).

Similar to the creation of a library you start to create an oroGen component using the command 'rock-create-orogen'. 

{coderay:: text}
~/dev$ rock-create-orogen basics_tutorial/orogen/message_producer
{coderay}

You will see the same configuration dialog as when calling rock-create-lib.

{coderay:: text}
------------------------------------------
We require some information to update the manifest.xml
------------------------------------------
Brief package description 
(Press ENTER when finished):
Message producer component
Long description: 
This component will produce simple, timestamped messages                    
Author: 
New user
Author email: 
new-user@rock-robotics.org
Url (optional):

Enter your dependencies as a comma separated list. 
Press ENTER when finished:
basics_tutorial/message_driver
{coderay}

All oroGen components should be created inside a separated folder called 'orogen' placed in the same folder as the libraries. In your case the libraries and the 'orogen' folder are placed in the 'basics_tutorials' folder. Moreover, when an oroGen component is created to integrate a library, it is highly recommended to use the same name than the library (here: message_producer).

### Define tasks

The previous command creates a new folder 'basics_tutorial/orogen/message_producer'. Inside you find two files: manifest.xml and message_producer.orogen.
The manifest.xml will have been filled with the information you provided already, but when you need to add additional dependencies to libraries or oroGen components you will have to edit manifest.xml directly. Since you want to use your newly created library, check that your library has been added as dependency.

{coderay:: xml}
<depend package="basics_tutorial/message_driver" />
{coderay}

The message_producer.orogen is the specification file of the your new oroGen component, and allows you to define Orocos tasks. 
The goal is to create a component which produces messages at a rate of 1 Hz, so the component only requires an output port for messages. 

{coderay:: ruby}
name "message_producer"

using_library "message_driver"
import_types_from "message_driver/Message.hpp"

task_context "Task" do
  output_port "messages", "message_driver/Message"
  periodic(1.0)
end
{coderay}

The specification contains a number of statement with the following meaning:

 * name: defines the name of the component, which is required for identification of the component
 * using_library: tells oroGen that this component requires, i.e. needs to link against the 'message_driver' library
 * import_types_from: tells oroGen that use a certain type, that is specified in the file following this statement
 * task_context: everything within this block defines an Orocos task context model, including what input and output ports are required and a default value for the runtime execution schema (every 1.0 second in this case)

The Task has an output port called 'messages' of type 'message_driver/Message'. This type is initially unknown to the component, but it can be found in the 'Message.hpp' header of the 'message_driver' library. the using_library statement tells oroGen only to look for a library of the given name and link it to any deployment. 
In order to make types known to your component so that you can use them in the specification, you have to do this explicitly with the 'import_types_from' statement.

### 

### Integration into the build system
Again, you should add you component to the build system by adding the package to autproj/manifest's layout section:

{coderay:: text}
package_sets:
  - gitorious: rock-toolchain/package_set

# Layout. Note that the rock.base, rock.toolchain 
# and orocos.toolchain sets are imported 
# by other rock sets.
layout:
  - rock.base
  - rock.toolchain
  - basics_tutorial/message_driver
  - basics_tutorial/orogen/message_producer
{coderay}

After adding it to the build system you can call amake for build the current package.

{coderay:: text}
amake
{coderay}

If you get an error here, you most likely have a syntax error, then please compare your files against the files in the tutorial package set.

### Writing the task
Now, that you have created the oroGen component you still have to embedd the functionality that message_driver provides, in order to achieve a proper message producing component. 

Calling 'rock-create-orogen' created several new files. For now, you only need to care about the files in the tasks/ subfolder and can safely ignore the templates folder for the moment. 

Within the subfolder 'tasks' of the created component you will find two files: 'Task.hpp' and 'Task.cpp'. They contain the skeleton for the Orocos component that has been created. Within 'Task.hpp' you will find several commented so-called hook methods, and you have to uncomment the methods you want to define in your task. For this tutorial you uncomment the updateHook.
(More information about this methods could be found [here](../orogen/task_states.html))

To add the message_driver functionality, add a forward declaration for message_driver and add a message_driver::MessageDriver member to the Task.hpp:

{coderay:: c++}
namespace message_driver {
    class MessageDriver;
}

namespace message_producer {
    class Task : public TaskBase
    {   
        friend class TaskBase;
    protected:
        message_driver::MessageDriver* mpMessageDriver;
...
{coderay}

Add the the message driver creation to the task's constructor and deallocation to the destructor.

{coderay:: c++}
#include <message_driver/MessageDriver.hpp>
...

Task::Task(std::string const& name,
		 TaskCore::TaskState initial_state)
    : TaskBase(name, initial_state)
    , mpMessageDriver(0)
{
    mpMessageDriver = new message_driver::MessageDriver();
}

Task::Task(std::string const& name, RTT::ExecutionEngine* engine,
	 	TaskCore::TaskState initial_state)
    : TaskBase(name, engine, initial_state)
    , mpMessageDriver(0)
{
    mpMessageDriver = new message_driver::MessageDriver();
}

Task::~Task()
{
    delete mpMessageDriver;
}
{coderay}

Also implement the updateHook, and make sure it is uncommented in the source and(!) the header file.
Within the update hook the messages port is accessed, which is identified by the name given in the specification and an '_' prefix. Since you specified the type for this port a 'message_driver::Message' can be written to the port. This update port is triggered at the rate that you specified in the the deployment section of the .orogen file.

{coderay:: c++}
void Task::updateHook()
{
    TaskBase::updateHook();

    message_driver::Message msg = mpMessageDriver->createMessage();
    _messages.write(msg);
}
{coderay}

To build your first component call:

{coderay:: text}
amake basics_tutorial/orogen/message_producer
{coderay}

Or, assuming that you are in the message_producer folder or in one of its
subfolders, you can use

{coderay:: text}
amake
{coderay}

Run it
-----------

Now, that you have a component ready to run, but probably want to see it running. Rock offers a ruby scripting interface for that purpose: [orocos.rb](../runtime/index.html)
So create a subfolder scripts in the message producer component and create a file start.rb.

{coderay:: ruby}
require 'orocos'
include Orocos

## Initialize orocos ##
Orocos.initialize

## Execute the task 'message_producer::Task' ##
Orocos.run 'message_producer::Task' => 'message_producer' do
  ## Get the task context##
  message_producer = Orocos.name_service.get 'message_producer'
  
  ## Start the tasks ##
  message_producer.start
  
  reader = message_producer.messages.reader
  
  while true
      if msg = reader.read_new
  	puts "#{msg.time} #{msg.content}"
      end
  
      sleep 0.1
  end
end
{coderay}

This scripts starts a process for the task 'message_producer' (The second argument behind Orocos.run gives the name to access it in the Orocos.run body). Once the message_producer has been created, the task can be accessed using 'Orocos.name_service.get'. Having the reference to the task context allows you to explicitly start the task. Run it using ruby. 

{coderay:: text}
ruby start.rb
{coderay}

The script prints only new messages that the producer provides. Since you set the periodicity to 1 second,  messages should show only every 1s. 

{coderay:: text}
Tue Aug 02 16:43:48 +0200 2011 Message from MessageDriver
Tue Aug 02 16:43:49 +0200 2011 Message from MessageDriver
{coderay}

Stop the script with CTRL+C. The script will stop the component process by
itself, which would happen also if you had an error in the script itself.

Summary
----------------------------
In this tutorial you have learned to: 

 * create a simple oroGen component
 * how to embed a library into an oroGen component
 * how to use Ruby to start oroGen components

Now that you have a rough idea of what oroGen is and can do, we recommend that you have a look at the [oroGen cheat sheet](../orogen/orogen_cheat_sheet.pdf).

In the next tutorial you will learn how to add configuration options to your task.

Progress to the [next tutorial](120_basics_configure_component.html).
