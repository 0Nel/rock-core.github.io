---
title: Creating components
sort_info: 110
---

Abstract
--------------

This tutorial will give you some handson experience on:

 * how to model an Orocos component and embed a library
 * how to run a component

If you don't want to execute the following steps by yourself, the result can also be found in 'tutorials/basics_tutorial'.
For this tutorial it is assumed that your autoproj installation can be found in ~/dev.

Creating an orogen component
--------------------------------
While Rock uses the Orocos Realtime Toolkit (Orocos RTT) to build its components upon, and uses the Orocos generation tool 'orogen' to easily create so-called orogen components. Orogen requires a component specification to generate a skeleton for you, which you can fill with the functionality you require.
This tutorial does not cover all details of Orocos components but you will find further information in the [orogen documentation](/documentation/orogen/index.html). 

Similar to the creation of a library you start to create an orogen component using the command 'rock-create-orogen'. 

{coderay:: sh}
~/dev$ rock-create-orogen basics_tutorial/orogen/message_producer
{coderay}

You will see the same configuration dialog as when calling rock-create-lib.

{coderay:: sh}
------------------------------------------
We require some information to update the manifest.xml
------------------------------------------
Brief package description 
(Press ENTER when finished):
Message producer component
Long description: 
This component will produce simple, timestamped messages                    
Author: 
New user
Author email: 
new-user@rock-robotics.org
Url (optional):

Enter your dependencies as a comma separated list. 
Press ENTER when finished:
basics_tutorial/message_driver
{coderay}

All orocos components should be created inside a separated folder called 'orogen' placed in the same folder as the libraries. In your case the libraries and the 'orogen' folder are placed in the 'basics_tutorials' folder.

### Define tasks and deployments

The previous command creates a new folder 'basics_tutorial/orogen/message_producer'. Inside you find two files: manifest.xml and message_producer.orogen.
The manifest.xml will have been filled with the information you provided already, but when you need to add additional dependencies to libraries or orocos components you will have to edit manifest.xml directly. Since you want to use your newly created library, check that your library has been added as dependency.
{coderay:: xml}
<depend package="basics_tutorial/message_driver" />
{coderay}

The message_producer.orogen is the specification file of the your new orogen component, and allows you to define Orocos tasks and deployments. 
The goal is to create a component which produces messages at a rate of 1 Hz, so the component only requires an output port for messages. 
{coderay:: ruby}
name "message_producer"

using_library "message_driver"
import_types_from "message_driver/Message.hpp"

task_context "Task" do
  output_port "messages", "message_driver/Message"
end

deployment "message_producer_deployment"
  task("message_producer", "Task").
      periodic(1)
end
{coderay}

The specification contains a number of statement with the following meaning:

 * name: defines the name of the component, which is required for identification of the component
 * using_library: tells orogen that this component requires, i.e. needs to link against the 'message_driver' library
 * import_types_from: tells orogen that use a certain type, that is specified in the file following this statement
 * task_context: everything within this block defines an Orocos task context model, including what input and output ports are required
 * deployment: using the task_context model specified in the previous block, a deployment is generated using the model, here: a task named 'message_producer' is created based on the "Task" model, additional properties can be specified, such as the periodicity of calling the so-called updateHook of the task, here: 1 second

The Task has an output port called 'messages' of type basics_tutorial/message. This type is initially unknown to the component, but it can be found in the 'Message.hpp' header of the 'message_driver' library. the using_library statement tells orogen only to look for a library of the given name and link it to any deployment. 
In order to make types known to your component so that you can use them in the specification, you have to do this explicitly with the 'import_types_from' statement.

### 

### Integration into the build system
Again, you should add you component to the build system by adding the package to autproj/manifest's layout section:
{coderay:: sh}
package_sets:
  - type: git 
    branch: $ROCK_FLAVOR
    url: $GITORIOUS_ROOT/rock-toolchain/package_set.git
    push_to: $GITORIOUS_PUSH_ROOT/rock-toolchain/package_set.git

# Layout. Note that the rock.base, rock.toolchain 
# and orocos.toolchain sets are imported 
# by other rock sets.
layout:
  - rock.base
  - rock.toolchain
  - basics_tutorial/message_driver
  - basics_tutorial/orogen/producer
{coderay}

After adding it to the build system you can call amake for build the current package.

{coderay:: sh}
amake
{coderay}

If you get an error here, you most likely have a syntax error, then please compare your files against the files in the tutorial package set.

### Writing the task
Now, that you have created the orogen component you still have to embedd the functionality that message_driver provides, in order to achieve a proper message producing component. 
With the execution of orogen command several new files have been created. For now, we only need to care about the files in the tasks subfolder and are ignoring the templates folder for a moment. 
Within the tasks folder you will find two files: 'Task.hpp' and 'Task.cpp'. They contain the skeleton for the Orocos component that has been created. Within 'Task.hpp' you will find several commented so-called hook methods, and you have to uncomment the methods you want to define in your task. For this tutorial you uncomment updateHook, startHook and cleanupHook.
(More information about this methods could be found [here](../orogen/task_states.html))

To add the message_driver functionality add a forward declaration for message_driver and add a message_driver::MessageDriver member to the Task.hpp:
{coderay:: c++}
namespace message_driver {
    class MessageDriver;
}

namespace message_producer {
    class Task : public TaskBase
    {   
        friend class TaskBase;
    protected:
        message_driver::MessageDriver* mpMessageDriver;
...
{coderay}

Add the the message driver creation to the task's constructor and deallocation to the destructor.
{coderay:: c++}
#include <message_driver/MessageDriver.hpp>
...

Task::Task(std::string const& name,
		 TaskCore::TaskState initial_state)
    : TaskBase(name, initial_state)
    , mpMessageDriver(0)
{
    mpMessageDriver = new message_driver::MessageDriver();
}

Task::Task(std::string const& name, RTT::ExecutionEngine* engine,
	 	TaskCore::TaskState initial_state)
    : TaskBase(name, engine, initial_state)
    , mpMessageDriver(0)
{
    mpMessageDriver = new message_driver::MessageDriver();
}

Task::~Task()
{
    delete mpMessageDriver;
}
{coderay}

Also implement the updateHook, and make sure it is uncommented in the source and(!) the header file.
Within the update hook the messages port is accessed, which is identified by the name given in the specification and an '_' prefix. Since you specified the type for this port a 'message_driver::Message' can be written to the port. This update port is triggered at the rate that you specified in the the deployment section of the .orogen file.

{coderay:: c++}
void Task::updateHook()
{
    TaskBase::updateHook();

    message_driver::Message msg = mpMessageDriver->createMessage();
    _messages.write(msg);
}
{coderay}

To build you first component call:
{coderay:: sh}
amake basics_tutorial/orogen/message_producer
{coderay}


Run it
-----------

Now, that you have a component ready to run, but probably want to see it running. Rock offers a ruby scripting interface for that purpose: [orocos.rb](../runtime/index.html)
So create a subfolder scripts in the message producer component and create a file start.rb.

{coderay:: ruby}
require 'orocos'
include Orocos

## Initialize orocos ##
Orocos.initialize

## Execute the deployment 'message_producer_deployment' ##
Orocos.run 'message_producer_deployment' do

  ## Get a the task context that is started with this deployment##
  message_producer = TaskContext.get 'message_producer'
  
  ## Start the tasks ##
  message_producer.start
  
  reader = message_producer.messages.reader
  
  while true
      if msg = reader.read_new
  	puts "#{msg.time} #{msg.content}"
      end
  
      sleep 0.1
  end
end
{coderay}

This scripts starts a process for the deployment 'message_producer_deployment'. Once the message_producer_deployment has been created, the task can be accessed using 'TaskContext.get'. Having the reference to the task context allows you to explicitly start the task. Run it using ruby. 
{coderay:: sh}
ruby start.rb
{coderay}

The script prints only new messages that the producer provides. Since you set the periodicity to 1 second,  messages should show only every 1s. 
{coderay:: sh}
Tue Aug 02 16:43:48 +0200 2011 Message from MessageDriver
Tue Aug 02 16:43:49 +0200 2011 Message from MessageDriver
{coderay}

Summary
----------------------------
In this tutorial you have learned to: 

 * create a simple orogen component
 * how to embed a library into an orogen component
 * how to use Ruby to start orogen components

In the next tutorial you will learn how to add configuration options to your task.

Progress to the [next tutorial](120_basics_configure_component.html).
