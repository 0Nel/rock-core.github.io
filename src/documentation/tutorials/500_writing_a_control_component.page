---
title: Writing a Control Component
sort_info: 500
---
Abstract
-----------
This tutorial is the basis for the followup tutorials in this section. Before you try this tutorial, 
you should have worked through the basic and visualization tutorials. 

In this tutorial, we will create a library for visualizing and simulating a 'Rock'-Robot. 
Further we will wrap it into an orocos task and fire it up. 

Implementation
-----------


### Create a new library
We start by entering the tutorials folder and creating a library named 'rock-tutorial' by using the 'rock-create-lib' command. 
{coderay:: sh}
cd tutorials
rock-create-lib rock_tutorial
{coderay}

This should give us an folder containing the following files :
{coderay:: sh}
CMakeLists.txt  INSTALL  LICENSE  manifest.xml  README  src
{coderay}

Make sure you add the required dependencies to the manifest.xml, i.e. here 'base/types' and 'gui/vizkit'.
{coderay:: sh}
<depend package="base/types" />
<depend package="gui/vizkit" />
{coderay}

Afterwards, create a new class in the src folder named 'RockControl'.

This class will contain the (very basic) simulation logic for our Rock-Robot. Therefore it will calculate new positions
of our robot given movement commands and a time step. 

{coderay:: c++}
#ifndef ROCKCONTROL_H
#define ROCKCONTROL_H

#include <base/motion_command.h>
#include <base/pose.h>

namespace rock_tutorial {

class RockControl
{

public:
    RockControl();
    virtual ~RockControl();
    
    base::Pose computeNextPose(const double &deltaTime, 
      const base::MotionCommand2D &command);

private:
    /**
    * Makes sure that angles are between PI and -PI.
    */
    void constrainAngle(double& angle);
    
    /**
    * This method constrains the relativ rotation and 
    * translation of a 2d motion command.
    * Rotation should be between PI an -PI.
    * Translation should be between 10 and -10.
    */
    void constrainValues(base::MotionCommand2D& motionCommand);
    
    /**
    * Current Position and orientation of the rock
    **/	
    base::Pose currentPose;

    /**
    * Current heading of the rock
    **/	

    double currentHeading;
    /**
    * Current speed of the rock
    **/	
    double currentRoll;

};

}

#endif // ROCKCONTROL_H
{coderay}


The implementation is rather straight forward and for readability reasons only relevant parts will be explained:

The type base::MotionCommand2D contains a demanded translation and a rotation speed. Translation is measured in m/s and 
rotation in rad/s. The parameter deltaTime defines, how much time advanced since the last call. The function 
+computeNextPose+ computes the new position and and rotation of our rock, in respect to the last pose.

{coderay:: c++}
base::Pose RockControl::computeNextPose(
  const double &deltaTime, 
  const base::MotionCommand2D &inputCommand)
{
  //limit the input values. 
  base::MotionCommand2D command = inputCommand;
  constrainValues(command);

  //calculate acceleration
  double delta_translation  = command.translation * deltaTime;
  double delta_rotation  = command.rotation * deltaTime;

  //apply new acceleration to rock state
  currentHeading += delta_rotation;
  currentRoll += delta_translation * -2;

  //limit the maximum speed and turn rate to sane values
  constrainAngle(currentHeading);
  constrainAngle(currentRoll);

  //calculate new absolut values for position and orientation
  currentPose.position += 
    Eigen::AngleAxisd(currentHeading, Eigen::Vector3d::UnitZ()) 
    * Eigen::Vector3d(0, delta_translation, 0);
  currentPose.orientation = 
    Eigen::AngleAxisd(currentHeading, Eigen::Vector3d::UnitZ()) 
    * Eigen::AngleAxisd(currentRoll, Eigen::Vector3d::UnitX());
  currentPose.orientation.normalize();

  return currentPose;
}
{coderay}


Now, that we got a 'proper' simulation of our rock, we go on and create a visualization for it.
Therefore, create a directory 'viz' and a class 'RockVisualization' in it:

{coderay:: c++}
#ifndef ROCKVISUALIZATION_H
#define ROCKVISUALIZATION_H

#include <base/pose.h>
#include <vizkit/Vizkit3DPlugin.hpp>

#include <osg/Node>
#include <osg/PositionAttitudeTransform>

namespace vizkit 
{
    
class RockVisualization: public vizkit::Vizkit3DPlugin<base::Pose>
{
  public:
    RockVisualization();
    void activateRockLabel(bool b);

  protected:ye
    virtual osg::ref_ptr<osg::Node> createMainNode();
    virtual void updateMainNode( osg::Node* node );
    void updateDataIntern ( const base::Pose& data );
    
    osg::ref_ptr<osg::Node> printPrimitivModel();
    osg::ref_ptr<osg::Node> printRockLabel();
    
    bool rockLabelActivated;
    base::Pose pose;
    osg::Vec3d position;
    osg::Quat orientation;
    osg::ref_ptr<osg::PositionAttitudeTransform> rockModelPos;
    osg::ref_ptr<osg::Node> rockModel;
    osg::ref_ptr<osg::Node> rockLabel;
};

//Macro that makes this plugin loadable in ruby.
VizkitQtPlugin(RockVisualization)

}
#endif // ROCKVISUALIZATION_H
{coderay}

This class tries to loads a model of a rock, and displays it at a position in space. 
In case that the model could not be loaded, it will fall back to a simple model 
of a sphere. As the implementation of it is mostly OpenSceneGraph code, we will not
explain it in detail here.


## Wrapping it up
So, now that we are equipped with our library, we can go to the second step and wrap the code into an orocos task.
As the visualization is already wrapped, we only need to wrap the 'simulation' part. Therefore we create a new orocos
component we use the command 'rock-create-orogen'. 
{coderay:: sh}
cd tutorials/orogen/
rock-create-orogen rock_tutorial
{coderay}

### Define tasks and deployments

Again we start by adding the build dependencies in the mainfest.xml. In this case we only depend on 'rock_tutorial', as 
rock_tutorial already depends on 'base/types' and the dependencies are resolved recursive.

In the rock_tutorial.orogen we will define the orocos tasks and the deployments. In the orogen file is already a demo task
and a demo deployment defined. For this tutorial it is recommend to replace them by our definitions:
{coderay:: ruby}
name "rock_tutorial"
version "0.1"

import_types_from "base"
using_library "rock_tutorial"

task_context "RockTutorialControl" do
  # Declare input port motion_command
  input_port "motion_command", "base::MotionCommand2D"
  # Declare output port pose
  output_port "pose", "base::Pose"
end
{coderay}

The task RockTutorialControl has an input port called 'motion_command' of type base::MotionCommand2D and an output port called 'pose' 
of type base::Pose. This task will compute a new position and orientation each time the update hook will triggered, given 
the translation and rotation speed it receives on its input port. The latest motion command will be used if there is no new one.
The update hook of this task will triggered periodically. That will be defined in the same .orogen file but in the deployment. 

{coderay:: ruby}
deployment "rock_tutorial" do
  # Declares task as periodic, with a period of 10ms
  task("rock_tutorial_control", "RockTutorialControl").
    periodic(0.01)
end
{coderay}

We add the task to the same deployment we already have. And make it periodic with a interval of 10 ms.
So we will get one deployment named 'rock_tutorial'.

The implementation is simple, as the task only calls the library and passes on the result.

{coderay:: c++}
bool RockTutorialControl::startHook()
{
  //delete last instance in case we got restarted
  if(control)
    delete control;

  //create instance of the controller
  control = new RockControl();

  //figure out the period in which the update hook get's called
  taskPeriod = TaskContext::getPeriod();

  return RockTutorialControlBase::startHook();
}

void RockTutorialControl::updateHook()
{    
  //read new motion command if available
  base::MotionCommand2D motionCommand;
  _motion_command.readNewest(motionCommand);

  //compute new position based on the input command
  base::Pose currentPose = 
    control->computeNextPose(taskPeriod, motionCommand);
  
  //write pose on output port
  if(_pose.connected())
    _pose.write(currentPose);
}
{coderay}


Run it
-----------

Now we should run it to see if it works. Create a scripts/ folder and create a
new <tt>rockTutorial1.rb</tt> script containing:

{coderay:: ruby}
require 'orocos'
require 'readline'
require 'vizkit'
include Orocos

## Initialize orocos ##
Orocos.initialize

## create a widget for 3d display
view3d = Vizkit.vizkit3d_widget

# show it
view3d.show

## load and add the 3d plugin for the rock
vizkit_rock = 
  view3d.createPlugin('rock_tutorial', 'RockVisualization')

## Execute the deployment 'rock_tutorial' ##
Orocos.run 'rock_tutorial' do

  ## Connect port to vizkit plugin
  con = Vizkit.connect_port_to 'rock_tutorial_control', 
          'pose', :update_frequency => 33 do |sample, name|
    ##pass every pose sample to our visualizer plugin
    vizkit_rock.updatePose(sample)
    sample
  end 

  ## Get a specific task context ##
  rockControl = TaskContext.get 'rock_tutorial_control'    

  ## Create a sample writer for a port ##
  sampleWriter = rockControl.motion_command.writer
  
  ## Start the tasks ##
  rockControl.start
  
  ## Write motion command sample ##
  sample = sampleWriter.new_sample
  sample.translation = 1
  sample.rotation = 0.5
  sampleWriter.write(sample)

  Vizkit.exec
end
{coderay}

and run it with

ruby rockTutorial1.rb
{: .commandline}

At first we create a widget for 3D-display and display it.
In the next step we load and register our self-written visualizer on the widget by calling  
createPlugin. 
Now, the deployment 'rock_tutorial' can be run. 
Every time there is a new sample the visualizer plugin should be updated. Therefore, we register a Ruby method that gets called every time there is a new 
sample on the 'pose' port. Inside this method we'll call our visualizer plugin with the new data sample. 

As in the basics tutorial, the following Ruby commands lead to a start of the task, i.e. calling the 
startHook() of the task. 
Afterwards we use a port writer to write a motion command to the 'motion_command' port.
Finally calling Vizkit.exec starts the GUI thread. 

What you can see after executing this script is a rock-like robot inside the Vizkit GUI. The rock should do a circular motion.
If you want to steer the rock using a joystick, progress to [the next
tutorial](510_joystick.html). If you don't have a joystick
go [to steer using a graphical interface](520_virtual_joystick.html)
