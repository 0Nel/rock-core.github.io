---
title: Basic workflow
sort_info: 400
---

Abstract
--------

[The previous tutorial](300_services.html) showed how to create abstract
compositions, and how to select what should run at the point where you add thing
to run (i.e. 'add' statements).

This tutorial describes a pretty typical development workflow when using Rock's
system management layer:

 * how to restart the deployments when developing the task contexts
 * how to define multiple subsystems and manage them at runtime
 * how to inspect a running system

Starting and restarting processes
---------------------------------
When developing components, one wants the specific processes to be restarted so
that the changes got picked up. In Rock's system management layer, it is done by
using the rock-roby shell.

In a terminal, run the script

rock-roby run scripts/rockRoby2.rb
{: .cmdline}

In another terminal, start the shell

rock-roby shell
{: .cmdline}

Let's now assume that you changed some code in the
rock_tutorial::RockTutorialControl task and would like to restart the
deployment. You would have to compile and install your changed task, for
instance by doing

amake tut_deployment
{: .cmdline}

Then, in the rock-roby shell we just created, type

TODO: create orocos.restart_deployments

orocos.restart_deployments RockTutorial::RockTutorialControl
{: .cmdline}

To restart all deployments, don't provide any argument

orocos.restart_deployments
{: .cmdline}

And, finally, CTRL+C the "rock-roby run" script. No need to stop the shell.

Defining modalities
-------------------
Right now, we have two ways to control our rock (so-called _modalities_):

 * by using a joystick
 * by using a random motion generator

Let's reflect that by _defining_, i.e. by giving a name to both the ways. Copy
the scripts/rockRoby2.rb to scripts/rockRoby3.rb and edit the latter: (1) remove the
'add' line at the bottom and (2) add the following lines:

{coderay:: ruby}
define('joystick', Cmp::RockControl).use(Controldev::JoystickTask)
define('random', Cmp::RockControl).use(TutBrownian::Task)
{coderay}

It would be now possible to use the names instead of the complete definition in
the 'add' lines, or in other definition's 'use()' statements. However, that's
not what we're going to do. Instead, we're going to use the shell to start
modalities and switch between them.

Start the rock-roby controller:

rock-roby run scripts/rockRoby3.rb
{: .cmdline}

In the shell, type

joystick!
{: .cmdline}

It requests that the supervision starts the joystick-based control, as you can
see in the live display:

TODO: add video

To inspect the set of running jobs, just do

TODO: implement jobs support

jobs
{: .cmdline}

The joystick-based control can now be stopped with

kill_job 1
{: .cmdline}

Alternatively, one can get the task object and stop it:

job(1).stop!
{: .cmdline}

Or

t = joystick!
t.stop!
{: .cmdline}

OK, now, let's try to start both the joystick and random control _at the same
time_.

joystick!
random!
{: .cmdline}
