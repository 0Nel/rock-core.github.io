---
title: Basic workflow
sort_info: 400
---

Abstract
--------

[The previous tutorial](300_services.html) showed how to create abstract
compositions, and how to select what should run at the point where you add thing
to run (i.e. 'add' statements).

This tutorial describes a pretty typical development workflow when using Rock's
system management layer:

 * how to restart the deployments when developing the task contexts
 * how to define multiple subsystems and manage them at runtime
 * how to inspect a running system

Starting and restarting processes
---------------------------------
When developing components, one wants the specific processes to be restarted so
that the changes got picked up. In Rock's system management layer, it is done by
using the rock-roby shell.

In a terminal, run the script

rock-roby run scripts/rockRoby2.rb
{: .cmdline}

In another terminal, start the shell

rock-roby shell
{: .cmdline}

Let's now assume that you changed some code in the
rock_tutorial::RockTutorialControl task and would like to restart the
deployment. You would have to compile and install your changed task, for
instance by doing

amake tut_deployment
{: .cmdline}

Then, in the rock-roby shell we just created, type

orocos.restart_deployments RockTutorial::RockTutorialControl
{: .cmdline}

To restart all deployments, don't provide any argument

orocos.restart_deployments
{: .cmdline}

And, finally, CTRL+C the "rock-roby run" script. No need to stop the shell.

Defining modalities
-------------------
Right now, we have two ways to control our rock (so-called _modalities_):

 * by using a random motion generator
 * by using a joystick

(Note if you don't have a joystick: you can do most of the tutorials without one
!)

Let's reflect that by _defining_, i.e. by giving a name to both the ways. Copy
the scripts/rockRoby2.rb to scripts/rockRoby3.rb and edit the latter: (1) remove the
'add' line at the bottom and (2) add the following lines:

{coderay:: ruby}
define('joystick', Cmp::RockControl).use(Controldev::JoystickTask)
define('random', Cmp::RockControl).use(TutBrownian::Task)
{coderay}

It would be now possible to use the names instead of the complete definition in
the 'add' lines, or in other definition's 'use()' statements. However, that's
not what we're going to do. Instead, we're going to use the shell to start
modalities and switch between them.

Start the rock-roby controller:

rock-roby run scripts/rockRoby3.rb
{: .cmdline}

In the shell, type

random!
{: .cmdline}

It requests that the supervision starts the joystick-based control, as you can
see in the live display:

TODO: add video

To inspect the set of running jobs, just do

TODO: implement jobs support

jobs
{: .cmdline}

The joystick-based control can now be stopped with

kill_job 1
{: .cmdline}

Alternatively, one can get the task object and stop it:

job(1).stop!
{: .cmdline}

Or

t = random!
t.stop!
{: .cmdline}

OK, now, let's try to start both the joystick and random control _at the same
time_.

random!
joystick!
{: .cmdline}

Ouch ... A lot of criptic information there ... Let's try to decode what
happened.

TODO: video or sequence of images

Stop the controller with CTRL+C and the shell with "exit", and pass on to the
next tutorial.

Summary
-------

In this tutorial you learned:

 * how to _define_ some ready-to-deploy networks, and how to use the shell to
   start them
 * how to manage the tasks started through the shell, in particular to support
   development of components
 * what happens if you try to deploy multiple tasks that can't be deployed at
   the same time

The _next tutorial_ will introduce you to config file management

