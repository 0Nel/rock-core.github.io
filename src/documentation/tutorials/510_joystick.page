---
title: Adding a Joystick into the Mix
sort_info: 510
---
Tutorial Info
-----------

This tutorial will give you some handson experience on:

 * how to find a 'standard' Rock package that provides a port X
 * how to install the package.
 * how to create a small control loop by attaching a Joystick to our rolling rock task.


Finding a standard task that provides a port X.
-----------

We are using here an existing task of the rock-robotics framework and the task from the previous 
tutorial, so we don't have to implement anything.

In order to get our control we need a task that supplies us with 'base::MotionCommand2D'. 
For that it is recommended to take a look into the [package directory](../../package_directory/).
You will have two options there:

 * look for a specific orogen package in the Packages section. For instance, you can search for
   "joystick orogen"
 * look for tasks that produce the type you require (here /base/MotionCommand2D) by going into
   the oroGen types section, selecting the type and looking at the Produced by section at the
   top of the page.

The package directory gives you a general overview of available 'standard' packages and types.
For our purpose we need to look into the subcategory 'oroGen Types'. This category shows all
available types that are exported by any task in the standard rock packages. As we are interested
on 'base::MotionCommand2D' we open the page about this type. Apart from the general description of
the type there is a section 'produced by' and 'consumed by', which gives us the list of all tasks
producing 'base::MotionCommand2D'. As we want to integrate a joystick, we pick controldev::JoystickTask
from the list, which is defined in 'drivers/orogen/controldev'.  

In order to install the package to your installation, either do 
{coderay:: sh}
autoproj build drivers/orogen/controldev
{coderay}
which will install the current version of the package, but not update / build it later,
or edit the manifest file in your autoproj directory to add it permanently.

Integration of the task
----------

Now that we have found a task, that supplies the needed motion commands we need to integrate it into
our run script. Therefore we modify the last runscript. By adding a joystick driver to it.
As we know from the package directory, the controldev package provides a tasks for our purpose. To find
out which exact task we can use we call 

{coderay:: sh}
rock-inspect -t controldev
{coderay}

This returns us an output of every installed task that is defined controldev.
The interesting part of the output is in our case this :

    ==========================================================
    Task name:  controldev::JoystickTask
    defined in controldev
    ----------------------------------------------------------
    
    ------- controldev::JoystickTask ------
    A Task that provides a joystick driver
    subclass of controldev::GenericTask (the superclass elements are displayed below)
    Ports
      [out]four_wheel_command:/controldev/FourWheelCommand
      [out]motion_command:/base/MotionCommand2D
      [out]raw_command:/controldev/RawCommand
      [out]speed_command:/base/SpeedCommand6D
      [out]state:/int32_t
    No dynamic ports
    Properties
      device:/std/string: Path to the joystick device
      maxRotationSpeed:/double: Maximum rotation speed in rad/s
      maxSpeed:/double: Maximum translation speed in m/s
      minRotationSpeed:/double: Minimum rotation speed in rad/s
      minSpeed:/double: Minimum translation speed in m/s
    No attributes
    No operations

This output tells us that there is a task controldev::JoystickTask, which has a
output port with the name 'motion_command' of the type '/base/MotionCommand2D'.
So it fits exactly our needs.

As we also need a deployment with the JoystickTask we check wether controldev already provides 
it. for doing so, we call

{coderay:: sh}
rock-inspect -t JoystickTask
{coderay}

this time, we are looking for deployments. We are in particular interested in:

    ==========================================================
    Deployment name:  joystick
    defined in controldev
    ----------------------------------------------------------
    
      ------- joystick ------
      Tasks
        joystick[controldev::JoystickTask]
          activity: FileDescriptorActivity, prio=25
          scheduler: realtime,
        joystick_Logger[logger::Logger]
          activity: Triggered, prio=lowest
          scheduler: non realtime

This tells us that there is a deployment joystick, which deploys the JoystickTask and thus also 
fits out needs. Note that the JoystickTask is deployed with the name 'joystick'.

Knowing this, we can now modify the script from the previous tutorial (copy it
to scripts/rockTutorial2.rb):

{coderay:: ruby}
require 'orocos'
require 'vizkit'
include Orocos

## Initialize orocos ##
Orocos.initialize

## create a widget for 3d display
view3d = Vizkit.vizkit3d_widget

# show it
view3d.show

## load and add the 3d plugin for the rock
vizkit_rock = view3d.createPlugin('rock_tutorial', 'RockVisualization')

## Execute the deployments 'rock_tutorial' and 'joystick' ##
Orocos.run 'rock_tutorial', 'joystick' do
  
    ## Connect port to vizkit plugin
    con = Vizkit.connect_port_to 'rock_tutorial_control', 'pose',
	    :update_frequency => 33 do |sample, name|
	##pass every pose sample to our visualizer plugin
        vizkit_rock.updatePose(sample)
        sample
    end 

    ## Get the specific task context ##
    rockControl = TaskContext.get 'rock_tutorial_control'
    joystick = TaskContext.get 'joystick'

    ## Connect the ports ##
    joystick.motion_command.connect_to rockControl.motion_command

    ## Set some properties ##
    joystick.device = "/dev/input/js0"

    ## Configure the tasks ##
    joystick.configure

    ## Start the tasks ##
    joystick.start
    rockControl.start

    Vizkit.exec
end

{coderay}

This script is quite the same as the script from rock tutorial 1, but with some improvements. As you can see
we execute a second deployment named 'joystick', besides the 'rock_tutorial' deployment.

Also we acquire a handle to the JoystickTask. Then we connect the output port 'motion_command'
of the task 'joystick' with the equal named input port of the task 'rockControl'. The task 'joystick' of course uses the 
joystick input to generate motion commands. In the next step we could set a property named 'device' of the task 'joystick'. 
With that we can set a string which is the local device of the joystick on your machine. Next we configure the 'joystick' 
task by issuing the command 'joystick.configure'. At least we will start all the Tasks. 

Run it
----------
You can now simply run it by executing
{coderay:: sh}
    ruby rockTutorial2.rb
{coderay}
If everything works, you should now
see a 3D-View of a rock on a plane and be able to steer it using your joystick.

