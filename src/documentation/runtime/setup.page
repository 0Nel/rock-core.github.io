---
title: Starting the system up
sort_info: 50
--- name:content pipeline:tags,markdown,blocks

Setting up CORBA
----------------

The CORBA communication layer is set up through the Orocos.initialize call. The
general header for an orocos.rb script is therefore:

{coderay:: ruby}
require 'orocos'
include Orocos
Orocos.initialize
{coderay}

It will connect to the default CORBA name server (in general, localhost), and
will raise if the name server can't be found.

If you want to use another name server, for instance because you have a system
spread on multiple machines and you want to manipulate modules on the various
machines, you have to enable the nameservice of your choice using
{rdoc_class: {base_url: /api/tools/orocos.rb, name:
Nameservice::enable}}
_before_ you call Orocos.initialize:

{coderay:: ruby}
require 'orocos'
include Orocos
Nameservice::enable(:CORBA, :host => "robot.local")
Orocos.initialize
{coderay}

***NOTE***: The setting of the CORBA nameservice directly using Orocos::CORBA.name_service is deprecated.
{: .warning}

Finally, the CORBA.call\_timeout and CORBA.connect\_timeout
specify timeouts at the CORBA level. See the {rdoc_class: {base_url:
/api/tools/orocos.rb, name: Orocos::CORBA}} documentation
for more information.

Nameservices
-----------------------------------------------

Two nameservices are currently available: CORBA and AVAHI.
Both can be used in parallel or standalone. 
For the CORBA nameservice the host address where the 
nameservice resides has to be provided:

{coderay:: ruby}
Nameservice::enable(:CORBA, :host => "127.0.0.1")
{coderay}

The AVAHI nameservice allows distributed name resolution, i.e. 
it does not require a centralized server.
For the name resolution via Avahi to work, deployments have to be started
with a service discovery domain set:

{coderay:: ruby}
Orocos.run 'deployment', 'cmdline_args' => { 'sd-domain' => '_robot._tcp' } do |p|
end
{coderay} 
This option is available to deployments
as soon as the tools/service_discovery package has been installed. 
Corresponding to the sd-domain the nameservice has to be enabled with 
a list of searchdomains (before calling Orocos.initialize).

{coderay:: ruby}
Nameservice::enable(:AVAHI, :searchdomains => ['_robot._tcp'])
{coderay}

The order in which nameservices are enabled also defines the search order. 

***Note***: in order to resolve the task context of the currently started deployment
allow the servicediscovery about one second after deployment start. Use the :wait 
option as illustrated in the next section.
{: .warning}

Starting processes _(oroGen-based modules only)_
------------------------------------------------

***Important***: the following functionality is only available for deployments
that have been generated by oroGen. However, the rest of orocos.rb's
functionality should work just fine with any RTT component.
{: .warning}

Orocos.rb has the ability to start deployments that are generated by oroGen
projects. The general syntax for that is:

{coderay:: ruby}
Orocos.run 'deployment1', 'deployment2' do |p1, p2|
end
{coderay}

where <tt>deployment1</tt> and <tt>deployment2</tt> are the names of the
deployments. In the above code snippet, the <tt>p1</tt> and <tt>p2</tt>
variables are the instances of {rdoc_class: {base_url: /api/tools/orocos.rb, name:
Orocos::Process}} that represent the
processes.

Orocos.run waits for all the processes to be up and running, and will raise an
exception if one fails to start, i.e. crashes or fails to start within a
specified timeout (0s by default). This timeout can be changed with the :wait
option:

{coderay:: ruby}
Orocos.run 'deployment1', 'deployment2', :wait => 10 do |p1, p2|
end
{coderay}

Orocos.run can also redirect the process outputs to files, and run them in
valgrind. See the {rdoc_class: {base_url: /api/tools/orocos.rb, name: Orocos, base_module: '', text: "documentation of the Orocos module"}} for more information.

