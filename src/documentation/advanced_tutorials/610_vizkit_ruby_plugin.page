---
title: Interface 3D Vizkit Plugins to Ruby
sort_info: 610
---
Abstract
-----------

In this tutorial you'll learn how to feed your Vizkit plugins with data input without using a separate orogen task.
All examples of this tutorial were made in the /tutorials/vizkit3d_plugin_tutorial/viz Vizkit plugin library.

Extensions to the Vizkit plugin
-----------

Everything we have to do in the plugin is to add at least two macros.

The first macro declares the Vizkit plugin as qtplugin. Because of the qt bindings it will be loadable on the ruby side.
The property has to be the name of the class, in this example it is SphereVisualization. You have to add this line at the bottom of the source file:
{coderay:: c++}
VizkitQtPlugin(SphereVisualization)
{coderay}


The second macro makes the default Vizkit plugin update method 'updateData(type)' available to ruby. Because ruby
doesn't support operator overloading the method must have an unique name. So it will be named partly by the third parameter of
this macro, it will be available as 'updatePosition' for this case. The first parameter is just the name of this class again.
And the second parameter is the type for which the 'updateData(type)' method should called. You have to add this line to the constructor of your Vizkit plugin:
{coderay:: c++}
VizPluginRubyAdapter(SphereVisualization, base::Vector3d, Position)
{coderay}
Note that this macro only could make the updateData methods available on the ruby side. We will discuss later on how to access other
methods too.


The Ruby Script
-----------

Now we can use a ruby script to load, feed and display the Vizkit plugin.
Don't forget to compile your changes you have made to the c++ source code.
You can execute the following lines in a separate ruby file or just in the irb (Interactive Ruby Shell).

{coderay:: ruby}
require 'vizkit'
require 'Qt4'
require 'vizkittypelib'
include Orocos
Orocos.initialize

# create an instance of the vizkit main window
# alternatively vizkit::QVizkitWidget could also be used
widget = Vizkit.default_loader.create_widget("vizkit::QVizkitMainWindow")
plugin = widget.createPlugin("vizkit3d_plugin_tutorial", "SphereVisualization")

# create an instance of the base type Vectro3d
position = Types::Base::Vector3d.new

# a global index
i = 0.0
# initialize timer
timer = Qt::Timer.new
timer.connect(SIGNAL('timeout()')) do
    i += 1.0
    j = i / 200.0
    position.x = Math::cos(j) * j
    position.y = Math::sin(j) * j
    position.z = 0.5
    
    plugin.updatePosition(position)
end

# start the timer with a timeout of 10 ms
timer.start(10)

widget.show
Vizkit.exec 
{coderay}

First of all we load the dependencies we need and initialize Orocos.
Next we instantiate the Vizkit main window and the SphereVisualization Vizkit plugin. The Vizkit window could be a QMainWindow or a QWidget. 
The first parameter in createPlugin is the name of the library and the second the class name of the Plugin. Than we create an instance of the base type Vector3d.
We are using a timer to feed the plugin periodically with new data using the method updatePosition.

The script can also be found in /tutorials/vizkit3d_plugin_tutorial/scripts.
If you execute it you should see the sphere flying in circles slowly away from the center.

Further Extensions
-----------

If you want to access other methods on ruby side, for configuration purposes for instance, then you can use the VizPluginRubyConfig macro or the Q_PROPERTY macro to add QObject properties. Those Properties will be accessible in a property tree on the Vizkit3DWidget GUI and also on the ruby side in the common QT way. A detailed description can be found [here](../data_analysis/data_visualization.html).

You have to add it to the constructor of the class, like the VizPluginRubyAdapter macro. 
{coderay:: c++}
VizPluginRubyConfig(SphereVisualization, float, setTransparency)
{coderay}
Here the first parameter is the name of the plugin class again. The second is the parameter type and the third is the name of the configuration method.

Therefore we have to add now the method setTransparency to our class
{coderay:: c++}
void SphereVisualization::setTransparency(float f)
{
    transparency = f;
}
{coderay}
add a private variable transparency of type float and use it to initially set the color for the sphere. 
This takes place in the method createMainNode:
{coderay:: c++}
...
sd->setColor(osg::Vec4(0.0f, 0.59f, 0.59f, transparency));
...
{coderay}

Now you can use the new method in the script. Don't forget to compile your changes you have made to the c++ source code.
{coderay:: ruby}
...
plugin = widget.createPlugin("vizkit3d_plugin_tutorial", "SphereVisualization")

# use a configuration method of the plugin to set the transparency of the sphere
plugin.setTransparency(0.5)
...
{coderay}

If we set the transparency to 0.5 the sphere should have a transparency of 50 percent.
So you can change easily values without recompiling.
