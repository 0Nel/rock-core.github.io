---
title: Data Visualization
sort_info: 500
---


Vizkit
----------------
One important aspect of data analysis is the visualization of data, be it
replayed from logs or live. How data is visualized is usually specific to the
problem, and most likely there is more than one way to show the data and their
relations. Simple values, like robot voltage level, can either be shown
directly or in a time series as a graph. More complex values sometimes also
allow the visualization as a graph or similar. But often, very specific
visualizations are required for complex data types. 

In Rock, the visualization like most other things, also works in a modularized
way. We believe that visualization is very problem specific, and there is no one
size fits all solution. Visualization components are essentially Qt widgets,
than can be connected to data sources and combined in an application specific to
the current problem or project. The aim of the Rock visualization part is to
provide an infrastructure and a collection of visualization components that
require as little as possible additional work to perform the visualization task
at hand. 

2D Visualization
----------------
For the purpose of 2D visualization Rock utilizes the QT-Framework. In particular,
the QT-Widgets. By default Rock provides a set of QT-Widgets that may be used out of
the box for visualizing 2D data. These widgets are called VizkitWidgets. Besides 
their C++ functionality these widgets provide a Ruby binding.

A full list of these widgets can be found in the [package directory](../../package_directory/). 


3D Visualization 
----------------
One particularly useful visualization is a 3D view, since it allows to show the
state of the robot's internal view on the world and also often internal states
and how they correlate to the environment model. 

For allowing easy and extendable 3D visualizations, Rock provides a specialized
VizkitWidget the Vizkit3DWidget. The Vizkit3DWidget provides a OpenSceneGraph-Context
and is a container for the Vizkit3DPlugins. Additionally, it offers some utility 
functions, for manipulating the point of view, and adding and removing of plugins.
As any other VizkitWidget it offers ruby binding.

{coderay:: cpp}
    void addDataHandler(VizPluginBase *viz);
    void removeDataHandler(VizPluginBase *viz);
    void setTrackedNode( vizkit::VizPluginBase* plugin );
    void changeCameraView(const osg::Vec3& lookAtPos, const osg::Vec3& eyePos);
{coderay}

The widget in itself only performs the linking between Qt and OpenSceneGraph,
but does not have an visualization abilities. These come in the form of plugins.
These plugins are called Vizkit3DPlugins. 
All plugins need to be derived from vizkit::Vizkit3DPlugin<>. 
As with the VizkitWidgets, Rock provides a set of
standard Vizkit3DPlugins that may be found in the [package directory](../../package_directory/).  

Using Vizkit
-------------------
Vizkit can be used in two way. Either one can create C++ only applications or
one may use the ruby bindings to create applications. 

As the ruby bindings allow greater flexibility in terms of integration into the
work flow of the rock world it is the preferred way. 

{coderay:: ruby}
require 'vizkit'
Orocos.initialize

## create a widget for 3d display
view3d = Vizkit.default_loader.
		create_widget('vizkit::Vizkit3DWidget')

#show it
view3d.show()

## load and add the 3d plugin for the rock
rbs_plugin = view3d.createPlugin('RigidBodyStateVisualization')
rbs = Types::Base::Samples::RigidBodyState.new

rbs.position = Eigen::Vector3.new(0, 5.0, 0)
rbs.orientation = Eigen::Quaternion.new(0, 0, 0, 1)

rbs_plugin.updateData(rbs)

#execute the main GUI loop
Vizkit.exec()

{coderay}


Writing Vizkit Plugins
----------------------
For writing your a custom Vizkit3DPlugin one needs to derive from the template 
class vizkit::Vizkit3DPlugin&lt;T&gt;, where the template argument T is the data type
that should be visualized. 

{coderay:: cpp}
#include <Eigen/Geometry>
#include <vizkit/Vizkit3DPlugin.hpp>

namespace vizkit 
{

class TrajectoryVisualisation 
	: public Vizkit3DPlugin<Eigen::Vector3d>
{
    public:
	TrajectoryVisualisation();    

    protected:
	virtual osg::ref_ptr<osg::Node> createMainNode()
	{
	    // create a new osg::Node object here, which 
	    // contains all the relevant structure that is needed
	    // e.g.
	    return new osg::Group();	
	}
	virtual void updateMainNode( osg::Node* node )
	{
	    // access to internal data is guarded in this method
	    // The node parameter is of the type that was 
	    // created in the createMainNode method.
	    
	    // update the node object to reflect the changes in 
	    // the internal data model
	}

	void updateDataIntern( const Eigen::Vector3d& data )
	{
	    // access to internal data is guarded in this method
	    path.push_back( data );
	}
};
    private:
	std::vector<Eigen::Vector3d> path;
}
{coderay}

You should put your plugin into the vizkit namespace. Using the Vizkit3DPlugin
template class, there is code that prevents that updateDataIntern and
updateMainNode are called at the same time.  
The Vizkit3DPlugin class provides an _updateData(const &Data)_ method, that can be called from the outside to update
the internal model of the node (e.g. set a new point in the trajectory). This
will in turn call the _updateDataIntern_ method, in which you can store updates to
your internal model (in this case a list of points). 

The updateMainNode is
called from within the visualization thread, when it is safe to access both your
internal model (e.g. the path vector) and the osg::Node that represents your
visualization. In this method, you need to modify the osg::Node to reflect the
internal state of the visualization (e.g. create the osg structures to visualize
the path). See the TrajectoryVisualization class in the vizkit package for an
actual implementation.

When writing plugins that don't visualize data types that are base data
types, they do not go into the vizkit package, but usually into the package
that defines the datatype to be visualized. Follow the convention and
 add a directory in that package with the name viz, that builds
optionally depending on weather gui/vizkit is available or not.

Therefore, the following needs to added to the package:
To the manifest:
{coderay:: xml}
<package>
    ...
    <depend package="gui/vizkit" optional="1" />
</package>
{coderay}

In the viz subdirectory an additional shared library needs to be created, that is
called the same way as the project, with the -viz suffix. So the CMakeLists.txt
file in the viz subdirectory should contain something like this:
{coderay:: cmake}
rock_vizkit_plugin(trajectory-viz
    TrajectoryVisualization.cpp 
    HEADERS TrajectoryVisualization.hpp)
{coderay}

