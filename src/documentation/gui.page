---
title: Graphical User Interface 
sort_info: 450
---

Robots can be very different and so are their user interfaces. To support the
programmer in a flexible way, a ruby library was introduced which brings Rock and
Qt together.

Based on this library there are a number of widgets which can be used to develop
a custom GUI in only a few minutes. For more complicated GUIs custom widgets
can easily be added by implementing the QDesignerCustomWidgetInterface.

Developing a Simple GUI
----------------
To show how to create a simple GUI, a small example is used which consists of
three elements.  A window, a button and a text field. The text field displays
the status of the robot and if someone clicks on the button the GUI is
sending a command to the robot.

The following code is generating the window, the button and the text field. The
underlying library is qtruby. Please see
[qtruby](http://techbase.kde.org/Development/Languages/Ruby) for more
informations about how to use the Qt ruby binding.

{coderay:: ruby}
  require 'vizkit'                      #loading library

  window = Qt::Widget.new               #create window
  button = Qt::PushButton.new(window)   #create button
  button.move(10,10)                    #set pos
  text_field = Qt::TextEdit.new(window) #create text field
  text_field.move 10,70                 #swret pos 
  window.show                           #show window

  #start deployment
  orocos.run 'my_deployment' do
    task = Orocos::TaskContext.get 'mytask'
    task.start
  
    #connect an output port to a code block
    #the output port is read with 8 Hz by default
    task.mystatus.connect_to do |data,port_name| 
      text_field.setText data.status.to_s
      #the data object must be returned
      data
    end

    #connect an input port to a qt signal
    writer = task.my_input.writer
    button.connect(SIGNAL('clicked()')) do 
        sample = writer.new_sample
        sample.field1 = "123"
        writer.write sample
    end

    #run qt main loop
    Vizkit.exec
  end
{coderay}

In the example above the connection between the text field and the output port
of the task is done via a code block which is triggered by a QTimer with a
default update frequency of 8 Hz. If it is necessary to retrieve all samples
from a port which has a higher update frequency, a buffered connection can be
used or the update frequency can be changed.

{coderay:: ruby}
  task.port.connect_to :type=> buffer, :size => 10,
                       :update_frequency => 10 
                       do |data,port_name| 
    data
  end
{coderay}

In the next example Vizkit is used to display the images taken by a camera.  If
Vizkit cannot find a specialised widget to visualize a message a tree view
widget is used to display all data fields. This mechanism can easily be extended
by custom widgets (see [writing custom widgets](#custom_widgets)).

{coderay:: ruby}
  require 'vizkit'
  orocos.run 'my_camera' do
    camera = Orocos::TaskContext.get 'camera'
    camera.start 
    Vizkit.display camera.frame
    Vizkit.exec
  end
{coderay}


Displaying Log Files
---------------
Log files are very import especially if it is expensive to run the software on
the robot in the real environment like it is very much the case, for example, in
underwater robotics. Therefore, it is the goal of Rock to provide the developer
with tools which are doing all the hard work to replay logged data to all his
components without changing his code more than necessary. For that reason it is
possible to use the same GUI for displaying logged data as well as it is used to
display live data.

If only the content of a log file matters and shall not be replayed to any
component the tool named rock-replay can be used to inspect the log files. A
double click on each listed message type will open a new widget which visualizes
the message. If no specialised widget can be found, a tree view widget is used to
display the content of the message.

{: .commandline}
rock-replay logfile1, logfile2, logfile3
{: .commandline}

All the mechanisms which rock-replay uses to visualizes a log file can be easily
used or extended by custom ruby scripts to display live data or log data.

For example, the code block below is using the same user interface as rock-replay
does to replay a log file to a custom qt widget.

{coderay:: ruby}
  require 'vizkit'
  require 'orocos/log'

  #open the log file
  replay = Orocos::Log::Replay.open("my.log") 

  #create window,button and text field
  window = Qt::Widget.new
  button = Qt::PushButton.new(window)
  button.move(10,10)
  text_field = Qt::TextEdit.new(window)
  text_field.move 10,70
  window.show

  #get logged task
  task = replay.mytask
  
  #connect the logged output port with the text field
  task.mystatus.connect_to do |data,port_name|
    text_field.setText data.status.to_s
    data
  end

  #show the control widget for the log file
  Vizkit.control replay

  #start gui
  Vizkit.exec
{coderay}

The next example is pretty much the start script of rock-replay
{coderay:: ruby}
require 'vizkit'
if ARGV.empty?
  puts
  puts "Programm for replaying log files"
  puts "Usage:"
  puts "replay logfile1, logfile2, ..."
  puts
  exit 1
end

log = Orocos::Log::Replay.open(ARGV)
#all ports shall be replayed
log.track true
Vizkit.control log
Vizkit.exec
{coderay}

If a specific port shall be replayed Vizkit can be used to automatically find 
a display widget which can handle the type of sample. This behavior can easily
be extended by registering custom widgets with the method 
Vizkit.register_widget_for (see [writing custom widgets](#custom_widgets)).

{coderay:: ruby}
  require 'vizkit'
  replay = Orocos::Log::Replay.open('my.log')
  Vizkit.display replay.mytask.myport
  Vizkit.control replay          
  Vizkit.exec
{coderay}

To specify the widget which shall be used to display the samples of the port,
the UiLoader class can be used to manually load widgets.  A complete list of
available widgets can be displayed by using the command line tool
rock-list-widgets.

{coderay:: ruby}
  require 'vizkit'
  replay = Orocos::Log::Replay.open('my.log')
  #create a new struct_viewer widget
  widget = Vizkit.default_loader.StructViewer
  replay.mytask.myport.connect_to widget
  widget.show
  Vizkit.exec 
{coderay}


Qt Designer
-------------------
![Qt Designer](qdesigner.png)

A graphical user interface can be developed either by writing source 
or a WYSIWYG editor like qt designer can be used to add and
arrange all widgets.  To support the developer in the best possible way there
is no need to convert the ui to another format it can be directly loaded by
Vizkit. After the ui file is loaded all widgets can be accessed by their object
name and all available slots and signals can be called on them. 

Example for loading an ui file which defines a text field with the object
name my_text_filed.
{coderay:: ruby}
  require 'vizkit'
  widget = Vizkit.load 'my.ui'
  #call the slot setText on the text field
  widget.my_text_filed.setText 'Hello Rock!'
  widget.show
  Vizkit.exec 
{coderay}

Available Widgets
-------------------
All standard qt and qwt widgets can be used from ruby. Furthermore rock is
shipped with a collection of widgets for some basic data analysis.

**ImageView:**
Widget for displaying camera images (base/frame/frame, base/frame/FramePair)

{coderay:: ruby}
  require 'vizkit'
  orocos.run 'my_camera' do
    camera = Orocos::TaskContext.get 'camera'
    camera.start 
    Vizkit.display camera.frame
    Vizkit.exec
  end
{coderay}

**PlotWidget:**
Widget for plotting sensor data

{coderay:: ruby}
  require 'vizkit'
  orocos.run 'my_sensor' do
    widget = Vizkit.default_loader.PlotWidget
    sensor = Orocos::TaskContext.get 'sensor'
    sensor.start 
    sensor.data.connect_to |sample,_|
      widget.addData sample.time.to_f,sample.data.to_f
    end
    Vizkit.exec
  end
{coderay}

**ArtificialHorizon:**
Widget for visualizing a rigid body state

Writing Custom ruby Widgets {#custom_widgets}
-------------------
Vizkit can easily be extended with custom ruby widgets. To do so follow the steps below:

  * write a new ruby class which is implementing the custom behaviour
  * register the widget so that Vizkit can find it 

For registering a new ruby widget call: Vizkit::UiLoader.register_ruby_widget
"name_of_widget", factory_method

Parameters:

  * name_of_widget = any name which is used to access the widget 
  * factory_method = method which shall be used to create a new instance 
  
For registering a new widget for a specific data type call: 
Vizkit::UiLoader.register_widget_for "name_of_widgte", "data_type", callback

Parameters:

  * name_of_widgte = name of the widget which shall be used for data display 
  * data_type = typlib data type for example "/base/samples/frame/Frame"
  * callback = function which shall be called on the widget to display the sample

After the widget is registered for a specific data type, a port which is of that
data type can be displayed by calling Vizkit.display port

Writing Custom C++ Widgets 
-------------------
Vizkit can easily be extended with custom c++ qt widgets. To do so follow the steps below:

 * write the custom qt c++ widget
 * all setter and getter methods must be implemented as slots or signals with qt data types as parameters
 * implement the QDesignerCustomWidgetInterface for the widget
 * install the widget as shared library (install/lib/qt/designer/)
 * write a ruby script to make the widget usable for Vizkit and require it after Vizkit is loaded

Example: ruby script which integrates a c++ widget into vizkit
{coderay:: ruby}
require 'eigen'

#the widget is automatically extended with the 
#following methods if it is loaded via 
#Vizkit.default_loader.widget_name

name = "ArtificialHorizon"
Vizkit::UiLoader.extend_cplusplus_widget_class name do 
  #function which is called when new data are available
  def update(sample,port_name)
      # pose and rigid body state
      if sample.respond_to?(:orientation) 
        sample = sample.orientation
      end

      if !sample.kind_of?(Eigen::Quaternion)
          # The base typelib plugin is not loaded, 
          # do the convertions by ourselves
          sample = Eigen::Quaternion.new(sample.re, 
                                         *sample.im.to_a)
      end

      angles = sample.to_euler(2,1,0)
      #call c++ slots to set the new orientation
      setPitchAngle(angles.y)
      setRollAngle(angles.z)
  end
end

#register widget to be automatically picked up when 
#Vizkit.display is called
Vizkit::UiLoader.register_widget_for(name,
                  '/wrappers/Orientation',:update)
Vizkit::UiLoader.register_widget_for(name,
                  '/wrappers/RigidBodyState',:update)
Vizkit::UiLoader.register_widget_for(name,
                  '/wrappers/samples/RigidBodyState',:update)
Vizkit::UiLoader.register_widget_for(name,
                  '/wrappers/Pose',:update)
{coderay}

***NOTE***:
For convenience, you can use the script *rock-create-qt-designer-widget* which 
basically does the steps listed above. Moreover, it generates all the necessary
code and build files for you and registers your widget with Qt Designer. 
See [here](advanced_tutorials/209_create_qt_designer_widget.html) for a detailed example.
{: .block}
