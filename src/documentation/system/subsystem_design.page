---
title: Subsystem Design
sort_info: 500
---
What we saw so far is the ability to __model__ how things should run together.
Data Services allow to represent abstract components. Compositions, to bind
components together to create some functionality.

However, there is still the problem of telling the system what should __actually
run__. This step is called _system deployment_.

At the root of everything are the __instance requirements__. They describe a
subsystem so that the rock-roby engine can create the network associated with
it.

Then, these requirements are used in various places to either predefine some
subsystems by giving them a name or directly inject them in the running system.

Instance Requirements
---------------------
The instance requirements describe a subsystem that you require to run. The
simplest of all is a single component model (either task or composition). For
instance:

{coderay:: ruby}
CorridorNavigation::FollowingTask
{coderay}

tells the system that you require a component of type
CorridorNavigation::FollowingTask to be running, not giving any other
constraints.

Compositions need a bit more information, as you might need to specify
composition children. For instance, the composition that handles the
CorridorNavigation::FollowingTask above requires a full robot pose, provided by
a Srv::Pose data service.

TODO: image

Instanciating it therefore requires to tell the system what should be used to
provide this pose. This is done by the #use statement:

{coderay:: ruby}
Cmp::CorridorFollowing.
  use(Srv::Pose => Cmp::PoseEstimation)
{coderay}

assuming that Cmp::PoseEstimation is a composition that can be instanciated "by
itself" (i.e. needs no other information to be instanciated). If it was needing
some more specification, you would specify it the same way (don't worry, there
are better ways to write that down)

{coderay:: ruby}
Cmp::CorridorFollowing.
  use(Srv::Pose => Cmp::PoseEstimation.
    use(Srv::Orientation => XsensImu::Task)
  )
{coderay}

The other thing that can be specified in an instance requirement are the task
arguments (as in [Roby task
arguments](http://rock-robotics.org/api/tools/roby/building_plans/configuration.html)).
This is simply done with #with_arguments:

{coderay:: ruby}
Cmp::CorridorServoing.
  with_arguments(:target_point => Eigen::Vector3.new(10, 12, 0)).
  use(Srv::Pose => Cmp::PoseEstimation.
    use(Srv::Orientation => XsensImu::Task)
  )
{coderay}

Finally, a special case of task arguments is the handling of the Orocos task
context configuration. One specifies it with #with_conf:

{coderay:: ruby}
Cmp::CorridorServoing.
  with_arguments(:target_point => Eigen::Vector3.new(10, 12, 0)).
  use(Srv::Pose => Cmp::PoseEstimation.
    use(Srv::Orientation => XsensImu::Task.with_conf('default', 'high_sampling_rate'))
  )
{coderay}

Deployment Files
----------------
Requirements can be given names by using #define in a deployment definition
file. These files are located in config/deployments/ and must be loaded
explicitely in either the robot config files or in its controller. To load a
config/deployments/main.rb file, one would do:

{coderay:: ruby}
Roby.app.apply_orocos_deployment 'main'
{coderay}

One can do three things in these files:

__1. Give names to specific requirements.__ This is done by calling
#define(name, requirement), as e.g.

{coderay:: ruby}
define('pose_estimator' Cmp::PoseEstimation.
    use(Srv::Orientation => XsensImu::Task))
{coderay}

Once that is done, the name can be used in other specifications:

{coderay:: ruby}
Cmp::CorridorServoing.
  with_arguments(:target_point => Eigen::Vector3.new(10, 12, 0)).
  use(Srv::Pose => 'pose_estimator')
{coderay}

__2. Define global use flags__ It is common that some "general" use flags can be
defined for a given system (i.e. define that Srv::Pose should always be resolved
with the same subsystem). It can be done in deployment files with:

{coderay:: ruby}
use Srv::Pose => Cmp::PoseEstimation.
    use(Srv::Orientation => XsensImu::Task)
{coderay}

Names can be used there as well

{coderay:: ruby}
use Srv::Pose => 'pose_estimator'
{coderay}

__3. Require that some things run.__ Finally, the #add_mission call can be used
to ask the engine to permanently run a specific subsystem, e.g.:

{coderay:: ruby}
add_mission('pose_estimator')
{coderay}

Orocos Deployments
------------------
Once a minimal network is generated from the set of requirements, one step is
left to do: choose actual deployments for the tasks that are running.

As always, if there are no possibilities (i.e. no choices need to be made), the
algorithm will pick the only solution.

However, if more than one deployment is available for a given RTT task context,
what should be done is a matter of policy.

If the task context is a device driver, i.e. needs to access hardware,
ambiguities are not acceptable (one deployment might have access to the required
hardware while the other has not). In this case, the deployment that has the
same name than the device will be used (if there is one), or an error will be
generated.

Otherwise, in principle, any deployment would do (since the location of the
actual task context might have a performance impact but no functional impact).
However, for performance reasons and for practical reasons (not knowing the task
name will make looking at the logged data harder), it is desirable to choose the
deployment explicitely. Enforcing that policy (i.e.  making the ambiguity an
error) is not yet the default for backward compatibility reasons, but that can
be changed by adding the following line at the end of config/init.rb (or in your
robot-specific config file)

{coderay:: ruby}
Roby.app.reject_ambiguous_processor_deployments = true
{coderay}

In any case, one chooses the deployments by providing "deployment hints". A hint
is a regular expression that is used to match the task names. It is recursive,
i.e. providing it at a composition level will make the hints available on the
children.

For instance, let's imagine that you have two sensor sets, one at the front and
one at the back of a vehicle. To instanciate the pose estimation processing for
both sets of sensors, one would require:

{coderay:: ruby}
Cmp::PoseEstimator.use_deployments(/front/).
  use(...)
Cmp::PoseEstimator.use_deployments(/back/).
  use(...)
{coderay}

where the dots are filled to select the required sensors (i.e. the list of
sensors on the front in the first case and the list of sensors on the back in
the second case).
