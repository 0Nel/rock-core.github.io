---
title: Subsystem Design
sort_info: 500
---
What we saw so far is the ability to __model__ how things should run together.
Data Services allow to represent abstract components. Compositions, to bind
components together to create some functionality.

However, there is still the problem of telling the system what should __actually
run__. This step is called _system deployment_.

At the root of everything are the __instance requirements__. They describe a
subsystem so that the syskit engine can create the network associated with
it.

Then, these requirements are used in Roby's action interface to allow to start
and stop complete subsystems dynamically.

Instance Requirements
---------------------
The instance requirements describe a subsystem that you require to run. The
simplest of all is a single component model (either task or composition). For
instance:

~~~ ruby
CorridorNavigation::FollowingTask
~~~

tells the system that you require a component of type
CorridorNavigation::FollowingTask to be running, not giving any other
constraints.

Compositions need a bit more information, as you might need to specify
composition children. For instance, the composition that handles the
CorridorNavigation::FollowingTask above requires a full robot pose, provided by
a Base::PoseSrv data service.

TODO: image

Instanciating it therefore requires to tell the system what should be used to
provide this pose. This is done by the #use statement:

~~~ ruby
CorridorFollowing.
  use(Base::PoseSrv => Cmp::PoseEstimation)
~~~

assuming that Cmp::PoseEstimation is a composition that can be instanciated "by
itself" (i.e. needs no other information to be instanciated). If it was needing
some more specification, you would specify it the same way (don't worry, there
are better ways to write that down)

~~~ ruby
CorridorFollowing.
  use(Base::PoseSrv => PoseEstimation.
    use(Base::OrientationSrv => XsensImu::Task)
  )
~~~

The other thing that can be specified in an instance requirement are the task
arguments (as in [Roby task
arguments](http://rock-robotics.org/api/tools/roby/building_plans/configuration.html)).
This is simply done with #with_arguments:

~~~ ruby
CorridorServoing.
  with_arguments(:target_point => Eigen::Vector3.new(10, 12, 0)).
  use(Base::PoseSrv => Cmp::PoseEstimation.
    use(Base::OrientationSrv => XsensImu::Task)
  )
~~~

Finally, a special case of task arguments is the handling of the Orocos task
context configuration. One specifies it with #with_conf:

~~~ ruby
Cmp::CorridorServoing.
  with_arguments(:target_point => Eigen::Vector3.new(10, 12, 0)).
  use(Base::PoseSrv => Cmp::PoseEstimation.
    use(Base::OrientationSrv => XsensImu::Task.with_conf('default', 'high_sampling_rate'))
  )
~~~


Profiles
--------
At some point, one has to bind everything togethr :xa

Requirements can be given names by using #define in a deployment definition
file. These files are located in config/deployments/ and must be loaded
explicitely in either the robot config files or in its controller. To load a
config/deployments/main.rb file, one would do:

~~~ ruby
Roby.app.apply_orocos_deployment 'main'
~~~


One can do three things in these files:

__1. Give names to specific requirements.__ This is done by calling
#define(name, requirement), as e.g.

~~~ ruby
define('pose_estimator' Cmp::PoseEstimation.
    use(Base::OrientationSrv => XsensImu::Task))
~~~


Once that is done, the name can be used in other specifications:

~~~ ruby
Cmp::CorridorServoing.
  with_arguments(:target_point => Eigen::Vector3.new(10, 12, 0)).
  use(Base::PoseSrv => 'pose_estimator')
~~~


__2. Define global use flags__ It is common that some "general" use flags can be
defined for a given system (i.e. define that Base::PoseSrv should always be resolved
with the same subsystem). It can be done in deployment files with:

~~~ ruby
use Base::PoseSrv => Cmp::PoseEstimation.
    use(Base::OrientationSrv => XsensImu::Task)
~~~


Names can be used there as well

~~~ ruby
use Base::PoseSrv => 'pose_estimator'
~~~


__3. Require that some things run.__ Finally, the #add_mission call can be used
to ask the engine to permanently run a specific subsystem, e.g.:

~~~ ruby
add_mission('pose_estimator')
~~~


Orocos Deployments
------------------
Once a minimal network is generated from the set of requirements, one step is
left to do: choose actual deployments for the tasks that are running.

Deployments must be made available to the rock-roby layer __explicitely__. The
default deployments generated by oroGen are currently not usable in rock-roby.
The best practice here is to create a single oroGen project for your system in
which you put __all__ the deployments that you will need.

You can then made all these deployments available in config/ROBOT.rb (where
ROBOT is the Roby robot name) with

~~~ ruby
Roby.app.use_deployments_from "my_orogen_project"
~~~


If, instead of loading all deployments from a project, one wants to register a
single deployment, he does so with

~~~ ruby
Roby.app.use_deployment "a_single_orogen_deployment"
~~~


(__Note__ Of course, more than one of project / deployment can be registered)

When trying to associate Orocos deployments to the generated component network,
as always, if there are a single possible solution, the algorithm will pick it.
However, __if more than one deployment is available__ for a given RTT task
context, what should be done is a matter of policy.

If the task context is a device driver, i.e. needs to access hardware,
ambiguities are not acceptable (one deployment might have access to the required
hardware while the other has not). In this case, the deployment that has the
same name than the device will be used (if there is one), or an error will be
generated.

Otherwise, in principle, any deployment would do (since the location of the
actual task context might have a performance impact but no functional impact).
However, for performance reasons and for practical reasons (not knowing the task
name will make looking at the logged data harder), it is desirable to choose the
deployment explicitely. Enforcing that policy (i.e.  making the ambiguity an
error) is not yet the default for backward compatibility reasons, but that can
be changed by adding the following line at the end of config/init.rb (or in your
robot-specific config file)

~~~ ruby
Roby.app.reject_ambiguous_processor_deployments = true
~~~


In any case, one chooses the deployments by providing "deployment hints". A hint
is a regular expression that is used to match the task names. It is recursive,
i.e. providing it at a composition level will make the hints available on the
children.

For instance, let's imagine that you have two sensor sets, one at the front and
one at the back of a vehicle. To instanciate the pose estimation processing for
both sets of sensors, one would require:

~~~ ruby
Cmp::PoseEstimator.use_deployments(/front/).
  use(...)
Cmp::PoseEstimator.use_deployments(/back/).
  use(...)
~~~


where the dots are filled to select the required sensors (i.e. the list of
sensors on the front in the first case and the list of sensors on the back in
the second case).
