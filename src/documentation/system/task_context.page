---
title: Extending Component Models
sort_info: 400
---

As mentionned earlier, the orocos-roby plugin generates one Roby task model for
each oroGen task context model it finds. Moreover, composition models are also 
This generated model is a subclass of Orocos::RobyPlugin::Composition which is
itself the grandchild of Roby::Task).

As such, much more can be done using Roby's runtime code execution features.

For instance, due to the limitations of the composition definition
implementation, one cannot currently use the complete range of event constraints
in the composition definition itself. This has to be done at runtime using one of the means, in Roby, to
[hook code blocks in task execution](http://rock-robotics.org/api/tools/roby/building_plans/tasks.html)

See [Roby's own documentation](http://rock-robotics.org/api/tools/roby) for more
information

Extending Compositions
----------------------
Extending compositions with new events, scripts or poll blocks is directly done
in the block given to composition. For instance:

{coderay:: ruby}
composition "Localization" do
  event :lost
  forward :lost => :failed
end
{coderay}

Extending Task Contexts
-----------------------
Since the subclass of Roby::Task that is created to represent an RTT task
context is not defined explicitely, one has to use a different mean than with
the compositions.

If a file in models/orogen/ exists, that has the same name than the oroGen
project but with a .rb extension, this file is going to be loaded after the
corresponding oroGen project is loaded and after the subclasses of Roby::Task
have been created. This can be used to extend these classes with custom events,
event handlers, ...

For instance, if one wants to add a poll handler to xsens_imu::Task, one would
create a models/orogen/xsens_imu.rb file and add the following code:

{coderay:: ruby}
class XsensImu::Task
  poll do
    # Do some polling
  end
end
{coderay}

__Note__ the concept of doing "class X .. end" like this to add something to an
_already existing_ class is called class reopening and is a standard feature of
the Ruby programming language.
{: .note}

Moreover, one can add, at the Roby level, a method that is going to be called at
component's configuration time before the component's own configureHook gets
called. This feature is commonly used to add task arguments to the model, and
use it to configure the task in cases where a configuration parameter depends on
the general context (i.e. cannot be statically written [in a configuration
file](configurations.html). Do not forget to call super there, as the
application of the task's configuration files is done in #configure as well.
For instance:

{coderay:: ruby}
class CorridorPlanner::Task
  argument :start_point
  argument :target_point

  def configure
    orogen_task.start_point = self.start_point
    orogen_task.target_point = self.target_point
    super
  end
end
{coderay}


