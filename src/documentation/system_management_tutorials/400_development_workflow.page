---
title: Basic workflow
sort_info: 400
---

Abstract
--------

[The previous tutorial](300_services.html) showed how to create abstract
compositions, and how to select what should run 
(at the point where you are using the 'add' statements).

This tutorial describes a typical development workflow when using Rock's
system management layer:

 * how to restart the deployments when developing the task contexts
 * how to define multiple subsystems and manage them at runtime
 * how to inspect a running system

Starting and restarting processes
---------------------------------
When developing components, one wants the specific processes to be restarted so
that the changes get picked up. In Rock's system management layer, it is done by
using the rock-roby shell.

In a terminal, run the script

rock-roby run scripts/rockRoby2.rb
{: .cmdline}

In another terminal, start the shell

rock-roby shell
{: .cmdline}

Let's now assume that you changed some code in the
rock_tutorial::RockTutorialControl task and would like to restart the
deployment. You would have to compile and install your changed task, for
instance by doing

amake tut_deployment
{: .cmdline}

Then, in the rock-roby shell we just created, type

orocos.restart_deployments RockTutorial::RockTutorialControl
{: .cmdline}

To restart all deployments, don't provide any argument

orocos.restart_deployments
{: .cmdline}

And, finally, CTRL+C the "rock-roby run" script. No need to stop the shell.

Defining modalities
-------------------
Right now, we have two ways (so-called _modalities_) to control our rock:

 * by using a random motion generator
 * by using a joystick

(Note if you don't have a joystick: you can do most of the tutorials without one
!)

Let's reflect that by _defining_, i.e. by giving a name to both the ways. Copy
the scripts/rockRoby2.rb to scripts/rockRoby3.rb and edit the latter: (1) remove the
'add' line at the bottom and (2) add the following lines:

{coderay:: ruby}
define('joystick', Cmp::RockControl).use(Controldev::JoystickTask)
define('random', Cmp::RockControl).use(TutBrownian::Task)
{coderay}

Using 'define' allows you to map a composition to a name and reference it lateron using this name lateron. It is 
then possible to use the name instead of the complete definition in
the 'add' lines, or in other definition's 'use()' statements. However, using 'add' or 'use' is 
not what we're going to do right now. Instead, we are going to use the shell to start these
modalities and switch between them.

Start the rock-roby controller:

rock-roby run scripts/rockRoby3.rb
{: .cmdline}

If you did not already do it, start a rock-roby shell in a separate terminal:

rock-roby shell
{: .cmdline}

In this shell, type:

joystick!
{: .cmdline}

It requests that the supervision starts the joystick-based control, as you can
see in the log or in the live display (if you start that in parallel):


{coderay:: text}
localhost:48902 > joystick!
=> #<service Roby::Task:0x7fedaea11a00{}[]>
localhost:48902 >
[1] joystick! started to plan
[1] joystick!: Roby::Task:0x7fedaea11a00{}[] has been replaced by Orocos::RobyPlugin::Compositions::RockControl:0x7fedae9f08f0{}[]
[1] joystick!: Orocos::RobyPlugin::Compositions::RockControl:0x7fedae9f08f0{}[] has been replaced by Orocos::RobyPlugin::Compositions::RockControl:0x7fedaead30b0{conf => [default]}[] 
[1] joystick!: task Orocos::RobyPlugin::Compositions::RockControl:0x7fedaead30b0{conf => [default]}[] started
{coderay}


To inspect the set of running jobs, just do:

jobs
{: .cmdline}

localhost:48902> jobs
1 joystick! #<DRb::DRbObject:0x7f35780b5fe0 @uri="druby://127.0.1.1:48902", @ref=70329407281240>
=> 
{:.cmdline}


The joystick-based control can now be stopped with

{coderay:: text}
localhost:48902> kill_job 1
[1] joystick!: task Orocos::RobyPlugin::Compositions::RockControl:0x7fedaead30b0{conf => [default]}[] failed
= fatal exception 1: mission failed: Orocos::RobyPlugin::Compositions::RockControl:0x7fedaead30b0{conf => [default]}[]
| [09:45:47.355 @7] Orocos::RobyPlugin::Compositions::RockControl:0x7fedaead30b0{conf => [default]}[]/failed
| The following tasks have been killed:
| #<Compositions::RockControl < Composition < Transformer::CompositionExtension>:0x7fedaead30b0
[1] joystick!: task Orocos::RobyPlugin::Compositions::RockControl:0x7fedaead30b0{conf => [default]}[] has been removed
{coderay}

Alternatively, one can get the task object and stop it:

job(1).stop!
{: .cmdline}

Or

{coderay:: text}
t = joystick!
t.stop!
{coderay}

OK, now, let's try to start both the joystick and random control _at the same
time_.

{coderay:: text}
random!
joystick!
{coderay}

Ouch, a lot of criptic information there: 
happened:
[![Parallel execution error](400_parallel_execution_error_thumb.png)](400_parallel_execution_error.png)

TODO: Let's try to decode what

Stop the controller with CTRL+C and the shell with "exit", and pass on to the
next tutorial.

Summary
-------

In this tutorial you learned:

 * how to _define_ some ready-to-deploy networks, and how to use the shell to
   start them
 * how to manage the tasks started through the shell, in particular to support
   development of components
 * what happens if you try to deploy multiple tasks that can't be deployed at
   the same time

The _next tutorial_ will introduce you to config file management

