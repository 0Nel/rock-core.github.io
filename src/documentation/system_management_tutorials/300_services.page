---
title: Going abstract - Data Services
sort_info: 300
only_on: master
---

Abstract
--------
In this tutorial, you will learn how to deal with _dependency injection_ in Rock's
system management layer. This feature allows you to specify
abstract compositions, where some (or all) of the parts are not actual
component instances but just component models (classes of components).

In a more concrete manner, this tutorial will show you:

 * how to change the RockControl composition so that any MotionCommand2D generator
   can be used, instead of just a joystick
 * how to select which command source should be used

The next tutorial will then deal with the _development workflow_ when using the
supervision: how to switch between different modalities / sources, how to
restart components that crashed, ...

Data Services
-------------
A data services allows to describe the interface a component. Thus, a data service describes 
things:

 * the (minimal) expected interface, i.e. what input and output ports a component has in order to support a given service
 * the expected functionality, i.e. currently only a meaningful service name informs about the functionality to be expected

For instance, a very common data service is the Pose service:

 * as its name implies, it generates poses
 * as its definition requires (not show here), it has a
   [base::samples::RigidBodyState](../base_types.html) output port

Other services (i.e. an Orientation service) would have the same output port,
but its name would reflect the fact that it does something different.

Abstracting the command generator
---------------------------------
In our case, we want to modify the result of the previous tutorial to allow the
selection of the command generator.

The first step is to define a generic CommandGenerator data service. Copy the
scripts/rockRoby1.rb to scripts/rockRoby2.rb and add the following before the
composition definition, but after the 'using_task_library' statements:

{coderay:: ruby}
# Defines a data service model, that can be accessed with
# DataServices::CommandGenerator or the shorter
# Srv::CommandGenerator
data_service_type 'CommandGenerator' do
  output_port 'cmd', '/base/MotionCommand2D'
end
{coderay}

This defines a DataService::CommandGenerator (or in short
Srv::CommandGenerator) data service model that can be used in place of the
joystick. Modify the composition definition as illustrated in the following:

{coderay:: ruby}
# Declare the composition. The new model can be accessed with either
# Compositions::RockControl or Cmp::RockControl
composition 'RockControl' do
  # Any command generator
  add Srv::CommandGenerator, :as => "cmd"
  # And one rock
  add RockTutorial::RockTutorialControl, :as => "rock"
  # Create any unique connection possible, by matching input and output ports
  # of the same data type. If ambiguities exist, an error is generated
  autoconnect
end
{coderay}

and let's make the instanciation fail:

rock-roby instanciate scripts/rockRoby2.rb
{: .cmdline}

You'll get an error: 

{coderay:: text}
= cannot find a concrete implementation for 1 task(s)
| placeholder for DataServices::CommandGenerator
|   no candidates
|   child cmd of Compositions::RockControl:0x7fc2ff5df470{conf => [default]}[]
{coderay}

[![Instanciation error](300_instanciate_error_output_thumb.png)](300_instanciate_error_output.png)

What rock-roby tries to tell you with this error messages is the following: it could not find an
implementation for the DataServices::CommandGenerator service. That's because
you never specified which tasks _provides_ can provide this service. Let's do that now.

Add the following after the data service declaration:

{coderay:: ruby}
Controldev::JoystickTask.provides Srv::CommandGenerator
{coderay}

The statement above tells the system that an instance of controldev::JoystickTask
provides the service 'CommandGenerator'. The supervision will verify that the task _does_
provide the required ports.

Note that the port type are important for matching connections and port names do not necessarily need to match between the service
and the task. The system management layer will map the names automatically _if
the mapping by type is unambiguous_. If multiple ports could be used, it will check if
there is one with the same name. If it is not the case, an error is generated
and you will have to specify the mapping manually [see also the API docs](http://rock-robotics.org/api/tools/orocos.rb/Orocos/RobyPlugin/CompositionModel.html#method-i-autoconnect)
{: .info}

and try again

rock-roby instanciate scripts/rockRoby2.rb
{: .cmdline}

[![Instanciation error](300_instanciate_output_thumb.png)](300_instanciate_output.png)

OK, now everything's fine. The system management layer knows only one component
that provides the CommandGenerator service, so it picked it up automatically and
generated the right network

Adding a random-motion generator
--------------------------------
The rock.tutorials package set contains a random-motion generator
(tutorials/orogen/tut_brownian) that we will now use as an alternative to the
joystick. 

First and foremost, when multiple oroGen projects start to be involved,
deployments quickly become hard to manage. The accepted workflow when you are
starting to build a complete system is to create a dedicated "deployment
project" that creates all the deployments that your system needs. In the case of
these tutorials, it is the tutorials/orogen/tut_deployment oroGen project. Have
a look at it, and make sure that it is built in your installation by either
adding manually to autoproj/manifest or [by building the whole rock.tutorials
package set once and for all](../tutorials/index.html#installing)

You now can integrate the random motion generator. Change the using_task_library
lines to match:

{coderay:: ruby}
using_task_library 'controldev'
using_task_library 'rock_tutorial'
using_task_library 'tut_brownian'
{coderay}

And change the use_deployment lines to match:

{coderay:: ruby}
use_deployment 'rock_tutorial'
use_deployment 'joystick'
use_deployment 'brownian'
{coderay}

Now, you also need to declare that the random motion generator does provide the
CommandGenerator service. Add the following after the data service declaration
from JoystickTask and after the 'use_deployment' statements:

{coderay:: ruby}
TutBrownian::Task.provides Srv::CommandGenerator
{coderay}

and let's make the instanciation fail again:

rock-roby instanciate scripts/rockRoby2.rb
{: .cmdline}

This time, there is another error:

{coderay:: text}
= cannot find a concrete implementation for 1 task(s)
| placeholder for Srv::CommandGenerator
|   2 candidates
|     Controldev::JoystickTask,
|     TutBrownian::Task
|   child cmd of Compositions::RockControl:0x7f6ff64c0780{conf => [default]}[]
{coderay}

Now, we are warned about two possibilities to get a
CommandGenerator service: the joystick and the random motion generator. Because
the selection is ambiguous, the system management layer refuses to proceed and
bails out.

We therefore need to select it before the component network can be generated. In order to do that, we need to give more details when adding
the composition, i.e. due to the two existing options for the CommandGenerator service, the 'add' line at the end of the file is not specific enough anymore. 
We additionally have to tell which task should be used in specific for the given composition: 

{coderay:: ruby}
# Read this as: deploy a RockControl composition, using
# the TutBrownian::Task in places where it makes sense
add(Cmp::RockControl).use(TutBrownian::Task)
{coderay}

The ambiguity is now resolved and instanciating the component network will work just fine:

rock-roby instanciate scripts/rockRoby2.rb
{: .cmdline}

[![Composition using TutBrownian](300_instanciate_brownian_thumb.png)](300_instanciate_brownian.png)

Running the final network
-------------------------

rock-roby run scripts/rockRoby2.rb
{: .cmdline}

Conclusion
----------
In this tutorial, you got started with using data services, i.e. description of
abstract components, and how to resolve ambiguities of different data sources at
requirement time (when calling 'add') instead of doing it at modelling time
(when creating the compositions)

The [next tutorial](400_development_workflow.html) deals with the _development workflow_ when using the
supervision: how to switch between different modalities / sources, how to
restart components that crashed, ...

