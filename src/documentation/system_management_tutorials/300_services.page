---
title: Going abstract - Data Services
sort_info: 300
only_on: master
---

Abstract
--------
In this tutorial, you will learn how to do _dependency injection_ in Rock's
system management layer. The goal of this feature is the ability to specify
abstract compositions, where some (or all) of the parts are not actual
components but just representations of classes of components.

In a more concrete manner, this tutorial will show you:

 * how to change the RockControl composition so that any MotionCommand2D generator
   can be used, instead of simply a joystick
 * how to select which command source should be used

The next tutorial will then deal with the _development workflow_ when using the
supervision: how to switch between different modalities / sources, how to
restart components that crashed, ...

Data Services
-------------
Data services are the component-based equivalent of interfaces. They define two
things:

 * an expected interface (input and output ports)
 * an expected functionality (informally defined through the service name)

For instance, a very common data service is the Pose service:

 * as its name implies, it generates poses
 * as its definition requires (not show here), it has a
   [base::samples::RigidBodyState](../base_types.html) output port

Other services (i.e. an Orientation service) would have the same output port,
but its name would reflect the fact that it does something different.

Abstracting the command generator
---------------------------------
In our case, we want to modify the result of the previous tutorial to allow the
selection of the command generator.

The first step is to define a generic CommandGenerator data service. Copy the
scripts/rockRoby1.rb to scripts/rockRoby2.rb and add the following before the
composition definition:

{coderay:: ruby}
# Defines a data service model, that can be accessed with
# DataServices::CommandGenerator or the shorter
# Srv::CommandGenerator
data_service_type 'CommandGenerator' do
  output_port 'cmd', '/base/MotionCommand2D'
end
{coderay}

This defines an DataService::CommandGenerator (or in short
Srv::CommandGenerator) data service model that can be used in place of the
joystick. Modify the composition definition:

{coderay:: ruby}
# Declare our composition. The new model can be accessed with either
# Compositions::RockControl or Cmp::RockControl
composition 'RockControl' do
  # Any command generator
  add Srv::CommandGenerator, :as => "cmd"
  # And one rock
  add RockTutorial::RockTutorialControl, :as => "rock"
  # Create any unique possible connection. If ambiguities
  # exist, an error is generated
  autoconnect
end
{coderay}

and let's make the instanciation fail:

rock-roby instanciate scripts/rockRoby2.rb
{: .cmdline}

You'll get an error that looks like

{coderay:: text}
= cannot find a concrete implementation for 1 task(s)
| placeholder for DataServices::CommandGenerator
|   no candidates
|   child cmd of Compositions::RockControl:0x7fc2ff5df470{conf => [default]}[]
{coderay}

What rock-roby tries to tell you there is that it could not find an
implementation for the DataServices::CommandGenerator service. That's because
you never told the models which tasks _provides_ the service. Let's do that now.

Add the following after the data service declaration:

{coderay:: ruby}
Controldev::JoystickTask.provides Srv::CommandGenerator
{coderay}

What this does is tell the system that the controldev::JoystickTask components
provide the required service. The models will verify that the task _does_
provide the required ports.

Note that the port names do not necessarily need to match between the service
and the task. The system management layer will map the names automatically _if
the mapping is unambiguous_. If multiple ports could be used, it will check if
there is one with the same name. If it is not the case, an error is generated
and you will have to specify the mapping manually. TODO: link to reference
documentation
{: .info}

and try again

rock-roby instanciate scripts/rockRoby2.rb
{: .cmdline}

OK, now everything's fine. The system management layer knows only one component
that provides the CommandGenerator service, so it picked it up automatically and
generated the right network

Adding a random motion generator
--------------------------------
The rock.tutorials package set contains a random motion generator
(tutorials/orogen/tut_brownian) that we will now use an an alternative to the
joystick. 

First and foremost, when multiple orogen projects start to be involved,
deployments becomes quickly hard to manage. The accepted workflow when you are
starting to build a complete system is to create a dedicated "deployment
project" that creates all the deployments that your system needs. In the case of
these tutorials, it is the tutorials/orogen/tut_deployment oroGen project. Have
a look at it, and make sure that it is built in your installation by either
adding manually to autoproj/manifest or [by building the whole rock.tutorials
package set once and for all](../tutorials/index.html#installing)

You now can integrate the random motion generator. Change the using_task_library
lines to match:

{coderay:: ruby}
using_task_library 'controldev'
using_task_library 'rock_tutorial'
using_task_library 'tut_brownian'
{coderay}

And change the use_deployment lines to match:

{coderay:: ruby}
use_deployment 'rock_tutorial'
use_deployment 'joystick'
use_deployment 'brownian'
{coderay}

Now, you also need to declare that the random motion generator does provide the
CommandGenerator service. Add the following after the data service declaration
from JoystickTask:

{coderay:: ruby}
TutBrownian::Task.provides Srv::CommandGenerator
{coderay}

and let's make the instanciation fail again:

rock-roby instanciate scripts/rockRoby2.rb
{: .cmdline}

This time, we get another error:

{coderay:: text}
= cannot find a concrete implementation for 1 task(s)
| placeholder for DataServices::CommandGenerator
|   2 candidates
|     Controldev::JoystickTask,
|     TutBrownian::Task
|   child cmd of Compositions::RockControl:0x7f6ff64c0780{conf => [default]}[]
{coderay}

The issue now is that there are two possibilities to get a
CommandGenerator service: the joystick and the random motion generator. Because
the selection is ambiguous, the system management layer refuses to choose and
bails out.

We therefore need to select it. In order to do that, we need to change the 'add'
line at the end of the file to tell him what to use:

{coderay:: ruby}
# Read this as: deploy a RockControl composition, using
# the TutBrownian::Task in places where it makes sense
add(Cmp::RockControl).use(TutBrownian::Task)
{coderay}

Instanciating it will now work just fine:

rock-roby instanciate scripts/rockRoby2.rb
{: .cmdline}

Running the final network
-------------------------

rock-roby run scripts/rockRoby2.rb
{: .cmdline}

TODO: video

Conclusion
----------
In this tutorial, you got a glimpse into the data services, i.e. description of
abstract components, and how to use them to select different data sources at
requirement time (when calling 'add') instead of doing it at modelling time
(when creating the compositions)

The [next tutorial](400_development_workflow.html) deals with the _development workflow_ when using the
supervision: how to switch between different modalities / sources, how to
restart components that crashed, ...

