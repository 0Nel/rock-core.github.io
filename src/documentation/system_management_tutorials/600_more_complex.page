---
title: Refining models - a leader/follower system
sort_info: 600
---

Abstract
--------
In this tutorial, you will learn one of the most important feature for
model-based systems: how generic models can be refined. In object-oriented
programming, this is more or less equivalent to subclassing.

This tutorial will guide through the process of:

 * changing the RockControl composition so that it can be adapted to the
   requirements of different motion control generators
 * how to transform a composition into a service, i.e. how to add ports to a
   composition

The leader-follower system
--------------------------
This tutorial will deploy a network in which:

 * one rock, controlled by the random motion generator, is a leader
 * another rock is following the first rock

The motion generator component for the follower is tut_follower::Task, included
in [Rock's rock.tutorial package set](../tutorials/index.html#installing)

The goal will be to reuse the same base model 'Cmp::RockControl' for both
deployments. The idea behind reusing in this case is:

 * you might have a diagnostics routine that is able to monitor the movement of
   a rock regardless of what controls it. Attaching that diagnostics routine to
   the RockControl composition will be sufficient, as it will apply to all
   refinements of this model.
 * it simplifies the usage of the compositions, as one only has to remember the
   name of a composition (Cmp::RockControl) and give an intent ('run the composition
   with X or Y') instead of having to remember N composition names.

Specializations
---------------
In Rock's system deployment layer, refinements of a composition model can be
created with _specializations_. Specializations can be seen as conditional
application of changes on compositions.

For instance, the following specialization specifies that when using
Cmp::RockControl, in cases where the command generator is a TutFollower::Task,
one child and two connections must be added to the composition. Copy
scripts/rockRoby3.rb to scripts/rockRoby4.rb, declare the TutFollower::Task to 
provide the CommandGenerator service and add the code for the 
specialization after the declaration of the Cmp::RockControl composition.

{coderay:: ruby}
TutFollower::Task.provides Srv::CommandGenerator
...
Cmp::RockControl.specialize 'cmd' => TutFollower::Task do
  # needs some other task/composition to provide a pose
  add Srv::Pose, :as => "target_pose"
  connect target_pose.pose_samples => cmd.target_position
  connect rock.pose_samples => cmd.current_position
end
{coderay}

As you can see, for this specialization we also introduce an additional service 'Pose'. We define it just 
after the previous service definition:

{coderay:: ruby}
data_service_type 'Pose' do
  output_port 'pose_samples', '/base/samples/RigidBodyState'
end
{coderay}


We have to make the TutFollower task's oroGen project available, and thus add the following line to the includes at the top of the file:

{coderay:: ruby}
using_task_library 'tut_follower'
{coderay}

Once such a specialization is added, it allows you to use the same composition for the random controller 
'TutBrownian::Task' and the follower controller 'TutFollower::Task':

{coderay:: ruby}
# Selects the "standard" composition
Cmp::RockControl.use(TutBrownian::Task)
# Selects the "specialized" composition
Cmp::RockControl.use(TutFollower::Task)
{coderay}

However, for the second one to be valid, we need a provider for the 'Pose' service: our 'leader' composition- which is a Cmp::RockControl
composition itself. For that to be possible, we need the 'leader' composition
to provide the 'Pose' service. To fulfill the requirements for the 'Pose' service, the composition needs an output port of type
base/samples/RigidBodyState. The following section describes how to add this port. 


Adding ports to compositions
----------------------------
Compositions cannot have their own ports. They can only _export_
ports from their children. In our case, the rock's pose is provided by the
RockTutorialControl task's pose_samples port. We will now change the original composition
model so that it exports this port and we declare the composition as
providing a Srv::Pose (make sure the 'Pose' service is defined before the composition block)

{coderay:: ruby}
composition 'RockControl' do
  ...
  export rock.pose_samples
  provides Srv::Pose
end
{coderay}

It is now possible to define our leader-follower system:

{coderay:: ruby}
define('leader', Cmp::RockControl.use(TutBrownian::Task))
define('system', Cmp::RockControl.use(TutFollower::Task, 'leader'))
{coderay}

Recheck the final system:

rock-roby instanciate scripts/rockRoby4.rb system
{: .cmdline}

Ouch

{coderay:: text}
= cannot deploy the following tasks
| Orocos::RobyPlugin::RockTutorial::RockTutorialControl:0x7fd637315370{conf => [default]}[]
|   child rock of Orocos::RobyPlugin::Compositions::RockControl:0x7fd637329fc8{conf => [default]}[]
| Orocos::RobyPlugin::TutFollower::Task:0x7fd6372ff318{conf => [default]}[]
|   child cmd of Compositions::RockControl/[cmd.is_a?(TutFollower::Task)]:0x7fd63734a700{conf => [default]}[]
| Orocos::RobyPlugin::RockTutorial::RockTutorialControl:0x7fd637315370{conf => [default]}[]: no deployments available
| Orocos::RobyPlugin::TutFollower::Task:0x7fd6372ff318{conf => [default]}[]: no deployments available
{coderay}

Ah ... yes, we need to add some deployments. The tut_deployment project contains all we
need so let's simply replace all the use_deployment lines by

{coderay:: ruby}
use_deployments_from 'tut_deployment'
{coderay}

and re-run the instanciate. Everything should be OK and the network is what we expect.

[![Leader follower network](600_leader_follower_thumb.png)](600_leader_follower.png)


You can also check the connections between the components by displaying the dataflow feature: 

[![Leader follower dataflow button](600_leader_follower_dataflow_button_thumb.png)](600_leader_follower_dataflow_button.png)


[![Leader follower dataflow](600_leader_follower_dataflow_thumb.png)](600_leader_follower_dataflow.png)

Finally, you can use a Vizkit script to display both rocks. If you have an existing one from a previous tutorial, copy it to scripts/display_system
and modify it so that it
 * adds two rock display plugins to the 3D view
 * connects to the two deployments from tut_deployment (rock-inspect tut_deployment)

The final script should look as follows:

{coderay:: ruby}
#! /usr/bin/env ruby

require 'orocos'
require 'vizkit'
include Orocos
## Initialize orocos
Orocos.initialize
## Create a widget for 3d display and show it
view3d = Vizkit.vizkit3d_widget
view3d.show
 
%w{follower target}.each do |deployment_name|
  ## load and add a 3d plugin for the rock
  vizkit_rock = view3d.createPlugin('rock_tutorial', 'RockVisualization')

  Vizkit.connect_port_to deployment_name, 'pose_samples' do |sample, name|
    ## Finally, pass every pose sample to our visualizer plugin
    vizkit_rock.updateData(sample)
    sample
  end
end

Vizkit.exec
{coderay}

Let's now run it and see our randomly moving rock being followed by the other one ...

Summary
-------
In this tutorial, you:

 * learned how to use specializations to refine the compositon models
 * learned how to "create" ports on a composition

