---
title: Refining models - a leader/follower system
sort_info: 600
---

Abstract
--------
In this tutorial, you will learn one of the most important feature for
model-based systems: how generic models can be refined. In object-oriented
programming, this is more or less equivalent to subclassing.

This tutorial will guide through the process of:

 * changing the RockControl composition so that it can be adapted to the
   requirements of different motion control generators
 * how to transform a composition into a service, i.e. how to add ports to a
   composition

The leader-follower system
--------------------------
This tutorial will deploy a network in which:

 * one rock, controlled by the random motion generator, is a leader
 * another rock is following the first rock

The motion generator component for the follower is tut_follower::Task, included
in [Rock's rock.tutorial package set](../tutorials/index.html#installing)

The goal will be to reuse the same base model 'Tutorials::RockControl' for both
deployments. The idea behind reusing in this case is:

 * you might have a diagnostics routine that is able to monitor the movement of
   a rock regardless of what controls it. Attaching that diagnostics routine to
   the RockControl composition will be sufficient, as it will apply to all
   refinements of this model.
 * it simplifies the usage of the compositions, as one only has to remember the
   name of a composition (Tutorials::RockControl) and give an intent ('run the composition
   with X or Y') instead of having to remember N composition names.

Specializations
---------------
In Syskit, refinements of a composition model can be
created with _specializations_. Specializations can be seen as conditional
application of changes on compositions.

For instance, the following specialization specifies that when using
Tutorials::RockControl, in cases where the command generator is a TutFollower::Task,
one child and two connections must be added to the composition. Copy
scripts/syskit4.rb to scripts/syskit5.rb, declare the TutFollower::Task to 
provide the CommandGeneratorSrv service and add the code for the 
specialization after the declaration of the Tutorials::RockControl composition.

{coderay:: ruby}
# Load common data services from the Rock bundle
require 'rock/models/blueprints/pose'

TutFollower::Task.provides CommandGeneratorSrv
...
Tutorials::RockControl.specialize Tutorials::RockControl.cmd_child => TutFollower::Task do
  # needs some other task/composition to provide a pose
  add Base::PoseSrv, :as => "target_pose"
  target_pose.pose_samples.connect_to cmd.target_position
  rock.pose_samples.connect_to cmd.current_position
end
{coderay}

We have to make the TutFollower task's oroGen project available, and thus add the following line to the includes at the top of the file:

{coderay:: ruby}
using_task_library 'tut_follower'
{coderay}

Once such a specialization is added, it allows you to use the same composition for the random controller 
'TutBrownian::Task' and the follower controller 'TutFollower::Task':

{coderay:: ruby}
# Selects the "standard" composition
Tutorials::RockControl.use(TutBrownian::Task)
# Selects the "specialized" composition
Tutorials::RockControl.use(TutFollower::Task)
{coderay}

However, for the second one to be valid, we need a provider for the
Base::PoseSrv service: our 'leader' composition- which is a Tutorials::RockControl
composition itself. For that to be possible, we need the 'leader' composition
to provide the Base::PoseSrv service.

We therefore need:

 - the composition to have an output port of type base/samples/RigidBodyState
 - a declaration of the fact that the composition does provide the data service

Adding ports to compositions
----------------------------
Compositions cannot have their own ports. They can only _export_
ports from their children. In our case, the rock's pose is provided by the
RockTutorialControl task's pose_samples port. We will now change the original composition
model so that it exports this port and we declare the composition as
providing a Base::PoseSrv

{coderay:: ruby}
module Tutorials
  class RockControl < Syskit::Composition
    ...
    export rock_child.pose_samples_port
    provides Base::PoseSrv
  end
end
{coderay}

It is now possible to define our leader-follower system:

{coderay:: ruby}
define('leader', Cmp::RockControl.use(TutBrownian::Task))
define('system', Cmp::RockControl.use(TutFollower::Task, leader_def))
{coderay}

Recheck the final system:

syskit instanciate scripts/syskit5.rb system
{: .cmdline}

Ouch

{coderay:: text}
= cannot deploy the following tasks
| RockTutorial::RockTutorialControl:0x7fd637315370{conf => [default]}[]
|   child rock of Tutorials::RockControl:0x7fd637329fc8{conf => [default]}[]
| TutFollower::Task:0x7fd6372ff318{conf => [default]}[]
|   child cmd of Tutorials::RockControl/[cmd.is_a?(TutFollower::Task)]:0x7fd63734a700{conf => [default]}[]
| RockTutorial::RockTutorialControl:0x7fd637315370{conf => [default]}[]: no deployments available
| TutFollower::Task:0x7fd6372ff318{conf => [default]}[]: no deployments available
{coderay}

Ah ... yes, we need to add some deployments. The tut_deployment project contains all we
need so let's simply replace all the use_deployment lines by

{coderay:: ruby}
use_deployments_from 'tut_deployment'
{coderay}

and re-run the instanciate. Everything should be OK and the network is what we expect.

[![Leader follower network](600_leader_follower_thumb.png)](600_leader_follower.png)

You can also check the connections between the components by displaying the dataflow feature: 

[![Leader follower dataflow button](600_leader_follower_dataflow_button_thumb.png)](600_leader_follower_dataflow_button.png)

[![Leader follower dataflow](600_leader_follower_dataflow_thumb.png)](600_leader_follower_dataflow.png)

Finally, you can use a Vizkit script to display both rocks. If you have an existing one from a previous tutorial, copy it to scripts/display_system
and modify it so that it
 * adds two rock display plugins to the 3D view
 * connects to the two deployments from tut_deployment (rock-inspect tut_deployment)

The display script should look as follows:

~~~ ruby
#! /usr/bin/env ruby

require 'orocos'
require 'vizkit'
include Orocos
## Initialize orocos
Orocos.initialize
## Create a widget for 3d display and show it
view3d = Vizkit.vizkit3d_widget
view3d.show
 
%w{follower target}.each do |deployment_name|
  ## load and add a 3d plugin for the rock
  vizkit_rock = view3d.createPlugin('rock_tutorial', 'RockVisualization')

  Vizkit.connect_port_to deployment_name, 'pose_samples' do |sample, name|
    ## Finally, pass every pose sample to our visualizer plugin
    vizkit_rock.updateData(sample)
    sample
  end
end

Vizkit.exec
~~~

Let's now run it and see our randomly moving rock being followed by the other one ...

Summary
-------
In this tutorial, you:

 * learned how to use specializations to refine the compositon models
 * learned how to "create" ports on a composition

