---
title: Refining models - a leader/follower system
sort_info: 600
---

Abstract
--------
In this tutorial, you will learn one of the most important feature for
model-based systems: how generic models can be refined. In object-oriented
programming, this is more or less equivalent to subclassing.

This tutorial will guide through the process of:

 * changing the RockControl composition so that it can be adapted to the
   requirements of different motion control generators
 * how to transform a composition into a service, i.e. how to add ports to a
   composition

The leader-follower system
--------------------------
This tutorial will deploy a network in which:

 * one rock, controlled by the random motion generator, is a leader
 * another rock is following the first rock

The motion generator component for the follower is tut_follower::Task, included
in [Rock's rock.tutorial package set](../basic_tutorials/index.html#installing)

The goal will be to reuse the same base model (Cmp::RockControl) for both
deployments. The idea behind reusing in this case is:

 * you might have a diagnostics routine that is able to monitor the movement of
   a rock regardless of what controls it. Attaching that diagnostics routine to
   the RockControl composition will be sufficient, as it will apply to all
   refinements of this model.
 * it simplifies the usage of the compositions, as one only has to remember the
   name of a composition (Cmp::RockControl) and give an intent (run the control
   with X or Y) instead of having to remember N composition names.

Specializations
---------------
In Rock's system deployment layer, refinements of a composition model can be
created with _specializations_. Specializations can be seen as conditional
application of changes on compositions.

For instance, the following specialization specifies that when using
Cmp::RockControl, in cases where the command generator is a TutFollower::Task,
one child and two connections must be added to the composition. Copy
scripts/rockRoby3.rb to scripts/rockRoby4.rb and add the code after the
declaration of the Cmp::RockControl composition.

{coderay:: ruby}
data_service_type 'Pose' do
  output_port 'pose_samples', '/base/samples/RigidBodyState'
end
TutFollower::Task.provides Srv::CommandGenerator

Cmp::RockControl.specialize 'cmd' => TutFollower::Task do
  add Srv::Pose, :as => "target_pose"
  connect target_pose.pose_samples => cmd.target_position
  connect rock.pose_samples => cmd.current_position
end
{coderay}

Once such a specialization is added, the following happens:

{coderay:: ruby}
# Selects the "standard" composition
Cmp::RockControl.use(TutBrownian::Task)
# Selects the "specialized" composition
Cmp::RockControl.use(TutFollower::Task)
{coderay}

However, for the second one to be valid, we now need to be able to give it a
pose. This pose will be provided by our leader, i.e. by a Cmp::RockControl
composition itself. However, for that to be possible, we need this composition
to provide the Srv::Pose service, and therefore have an output port of type
base/samples/RigidBodyState.

Adding ports to compositions
----------------------------
In this system, compositions can't have their own ports. They can only _export_
ports from their children. In our case, the rock pose is provided by the
RockTutorialControl task's pose_samples port. Let's change original composition
model to export this port to the outside of the composition, and declare it as
providing a Srv::Pose (you'll need to move the definition of the Pose service
before the composition block)

{coderay:: ruby}
composition 'RockControl' do
  ...
  export rock.pose_samples
  provides Srv::Pose
end
{coderay}

It is now possible to define our leader-follower system:

{coderay:: ruby}
define('leader', Cmp::RockControl.use(TutBrownian::Task))
define('system', Cmp::RockControl.use(TutFollower::Task, 'leader'))
{coderay}

and look at the result

rock-roby instanciate scripts/rockRoby4.rb system
{: .cmdline}

Ouch

{coderay:: text}
= cannot deploy the following tasks
| Orocos::RobyPlugin::RockTutorial::RockTutorialControl:0x7fd637315370{conf => [default]}[]
|   child rock of Orocos::RobyPlugin::Compositions::RockControl:0x7fd637329fc8{conf => [default]}[]
| Orocos::RobyPlugin::TutFollower::Task:0x7fd6372ff318{conf => [default]}[]
|   child cmd of Compositions::RockControl/[cmd.is_a?(TutFollower::Task)]:0x7fd63734a700{conf => [default]}[]
| Orocos::RobyPlugin::RockTutorial::RockTutorialControl:0x7fd637315370{conf => [default]}[]: no deployments available
| Orocos::RobyPlugin::TutFollower::Task:0x7fd6372ff318{conf => [default]}[]: no deployments available
{coderay}

Ah ... yes, we need to add some deployments. The tut_deployment project contains all we
need so let's simply replace all the use_deployment lines by

{coderay:: ruby}
use_deployments_from 'tut_deployment'
{coderay}

and re-run the instanciate. Everything should be OK and the network is what we expect.

Finally, modify scripts/display to display both rocks. Copy it to scripts/display_system
and modify it so that it
 * adds two rock display plugins to the 3D view
 * connects to the two deployments from tut_deployment (rock-inspect tut_deployment)

A solution would be:

{coderay:: ruby}
#! /usr/bin/env ruby

require 'orocos'
require 'vizkit'
include Orocos
## Initialize orocos
Orocos.initialize
## Create a widget for 3d display and show it
view3d = Vizkit.vizkit3d_widget
view3d.show
 
%w{follower target}.each do |deployment_name|
  ## load and add a 3d plugin for the rock
  vizkit_rock = view3d.createPlugin('rock_tutorial', 'RockVisualization')

  Vizkit.connect_port_to deployment_name, 'pose_samples',
    :auto_reconnect => true, :pull => false,
    :update_frequency => 33 do |sample, name|

    ## Finally, pass every pose sample to our visualizer plugin
    vizkit_rock.updatePose(sample)
    sample
  end
end
{coderay}

Let's now run it and see our randomly moving rock being followed by the other one ...

However, which is which (actually ?). Two deployments exist for the RockTutorialControl
and nowhere did we specify which should be picked. So, what happened ?

Summary
-------
In this tutorial, you:

 * learned how to use specializations to refine the compositon models
 * learned how to "create" ports on a composition

The next tutorial will lead you towards device modelling, and its importance in a
complete system.

