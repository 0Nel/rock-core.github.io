---
title: Bundle File Structure
sort_info: 700
---

All these tutorials were dealing with "everything in a file". We felt that it
was a better way to understand how everything fits together.

However, as we saw [in the leader-follower tutorial](600_more_complex.html), we
want to be able to share and reuse the models and definitions. Moreover, having
everything in a single file obviously does not scale very well ...

This page will simply introduce where all the bits and pieces are stored in a
given bundle, as well as additional concepts that were not introduced in the
tutorials.

When starting from a given bundle, the syskit application will __automatically__
load all model files contained in said bundle. Therefore, when creating scripts
in scripts/, all the models defined in models/ __are__ available. The
modifications described in this page will therefore break the scripts (there
will be duplicate definitions).

For this reason, the result of the modifications described on this page are
contained on a separate branch in bundles/tutorials, called "file-structure".
You can check it out with

~~~
git checkout autobuild/file-structure
~~~

Blueprints
----------
[Data services](../system/data_services.html) and
[compositions](../system/compositions.html) are defined in models/blueprints.
They must require any other file they need, and either use import_types_from
'typekit' to get the required types or using_task_library 'project' for the task
contexts. The file name should by convention be the name of the model defined
and the namespace the same than the bundle name (the rock bundle is an exception
here).

For instance, the scripts/04_leader_follower.rb script would be split into:

__models/blueprints/command_generator_srv.rb__:

~~~ ruby
import_types_from 'base'
module Tutorials
  data_service_type 'CommandGeneratorSrv' do
    output_port 'cmd', '/base/MotionCommand2D'
  end
end
~~~

__models/blueprints/rock_control.rb__

~~~ ruby
require 'models/blueprints/command_generator_srv'
using_task_library 'rock_tutorial'
module Tutorials
  class RockControl < Syskit::Composition
    add CommandGeneratorSrv, :as => "cmd"
    add RockTutorial::RockTutorialControl, :as => "rock"
    cmd_child.connect_to rock_child

    conf 'slow',
        cmd_child => ['default', 'slow']

    export rock_child.pose_samples_port
    provides Base::PoseSrv, :as => 'pose'
  end
end
~~~


Task Context Modelling
----------------------

The main models for the task contexts are automatically generated by Syskit
based on the oroGen description. What we did in these tutorials was "extending"
these models, most often to declare that they provide some data service.

These extensions are declared in files in models/orogen/, where file names must
be the name of the corresponding oroGen project. These files are loaded
automatically whenever the corresponding oroGen project is. As for with files in
models/blueprints, the relevant data services must be explicitely required in
these files. No need to use import_types_from and/or using_task_library: the
relevant typekits and type libraries are already loaded.

The _provides_ lines in scripts/04_leader_follower.rb would therefore be split
into four files:

__models/orogen/controldev.rb__

~~~ ruby
require 'models/blueprints/command_generator_srv'
Controldev::JoystickTask.provides Tutorials::CommandGeneratorSrv, :as => 'cmd'
~~~

__models/orogen/tut_brownian.rb__

~~~ ruby
require 'models/blueprints/command_generator_srv'
TutBrownian::Task.provides Tutorials::CommandGeneratorSrv, :as => 'cmd'
~~~

__models/orogen/tut_follower.rb__

~~~ ruby
require 'models/blueprints/command_generator_srv'
TutFollower::Task.provides Tutorials::CommandGeneratorSrv, :as => 'cmd'
~~~

Specializations
---------------
A specialization can either be given along with the specialized composition or
within the relevant oroGen extension file (in config/orogen). There is currently
no clear winner when considering discoverability or reusability.

Let's assume we put it with the composition. Modify
__models/blueprints/rock_control.rb__ so that the end of the RockControl class
definition looks like:

~~~ ruby
module Tutorials
  class RockControl < Syskit::Composition
    [snip]

    specialize cmd_child => TutFollower::Task do
      add Base::PoseSrv, :as => "target_pose"
      add TutSensor::Task, :as => 'sensor'

      target_pose_child.connect_to sensor_child.target_frame_port
      rock_child.connect_to sensor_child.local_frame_port
      sensor_child.connect_to cmd_child
    end
  end
end
~~~

Definitions
-----------

Definitions are declared in [profiles](../system/profiles.html), Profiles are
set of predefined actions that can be injected in relevant Syskit applications
by 'using' them in an action interface.

The profile is defined within a namespace that matches the bundle name, in
models/profiles/. The file name should be the name of the profile:

__models/profiles/rocks.rb__

~~~ ruby
module Tutorials
  profile 'Rocks' do
    define 'joystick',    Tutorials::RockControl.use(Controldev::JoystickTask)
    define 'random',      Tutorials::RockControl.use(TutBrownian::Task)
    define 'random_slow', Tutorials::RockControl.use(TutBrownian::Task.with_conf('default', 'slow'))
    define 'random_slow2', Tutorials::RockControl.use(TutBrownian::Task).with_conf('slow')
    define 'leader',
      Tutorials::RockControl.use(TutBrownian::Task).
        use_deployments(/target/)
    define 'follower',
      Tutorials::RockControl.use(TutFollower::Task, leader_def).
        use_deployments(/follower/)
  end
end
~~~

The 'main' action interface is already defined in models/actions/main.rb. You
simply have to declare that you want to use the new profile:

__models/actions/main.rb__

~~~ ruby
require 'models/profiles/rocks'
class Main < Roby::Actions::Interface
  use_profile Tutorials::Rocks
end
~~~
    
Deployments
-----------
Finally, deployments are 'used' in the robot's config file or in config/init.rb.
When it is in init.rb, it must be done after the Roby.app.using 'syskit' line.

First, let's add a 'tut' robot

~~~
# roby add-robot tut
~~~

And edit its main configuration file:

__config/tut.rb__

~~~ ruby
Syskit.conf.use_deploments_from 'tut_deployment'
~~~

Finally
-------

You can finally use syskit run, syskit browse and syskit instanciate. syskit
browse does not need any arguments. run and instanciate will need you to specify
a -rtut argument, to tell roby that you want the 'tut' configuration to
be loaded:

~~~
syskit run -rtut follower!
~~~
