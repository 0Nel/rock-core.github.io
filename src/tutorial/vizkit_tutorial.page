---
title: Vizkit-Plugin Tutorial
sort_info: 7
---
Abstract
-----------

In this tutorial you'll learn how to create your own Vizkit plugin.
All examples of this tutorial were made in the /tutorials/rock_tutorial/viz library.


Implementation
-----------

Normally you add a Vizkit plugin to an existing library, to visualize data of this library.
In this example we add a Vizkit plugin to the 'rock_tutorial' library.

The first step is to execute the following command inside the folder of this library.
{coderay:: sh}
rock-add-vizkit
{coderay}
You'll be asked for a name and a type for the plugin. The name should be a simple name as PathVisualization, without namespaces. The type is the type we want to display and should be something like base::Time (with namespace). In our case we use RockVisualization as name and base::Pose as type. 
After that all files we need for the plugin were created in a separated folder named 'viz'.

In the header file we can see that this plugin inherits from vizkit::VizPlugin<base::Pose>. From VizPlugin it has a method updateData of parameter base::Pose. This method will be called later from orocos components or ruby scripts to update its internal state.
But we only have to take care of the three virtual methods.
{coderay:: c++}
#include <boost/noncopyable.hpp>
#include <vizkit/VizPlugin.hpp>
#include <osg/Geode>

namespace vizkit
{
    class RockVisualization
        : public vizkit::VizPlugin<base::Pose>
        , boost::noncopyable
    {
    public:
        RockVisualization();
        ~RockVisualization();

    protected:
        virtual osg::ref_ptr<osg::Node> createMainNode();
        virtual void updateMainNode(osg::Node* node);
        virtual void updateDataIntern(base::Pose const& plan);
        
    private:
        struct Data;
        Data* p;
    };
}
{coderay}

In createMainNode we have to create an osg node (e.g. osg::Geode, osg::Group, osg::Node), add to it all geometries we want to display and return it.
{coderay:: c++}
osg::ref_ptr<osg::Node> RockVisualization::createMainNode()
{
    // Geode is a common node used for vizkit plugins. It allows to display
    // "arbitrary" geometries
    return new osg::Geode();
}
{coderay}

The updateMainNode is an update callback of osg, it gets triggered when the internal states of the geometries can be updated.
So what we have to do here is to update our nodes using the data in p->data.
{coderay:: c++}
void RockVisualization::updateMainNode ( osg::Node* node )
{
    osg::Geode* geode = static_cast<osg::Geode*>(node);
    // Update the main node using the data in p->data
}
{coderay}

This method gets executed by the updateData method and updates the internal state of our type base::Pose.
We don't need to change here anything.
{coderay:: c++}
void RockVisualization::updateDataIntern(base::Pose const& value)
{
    p->data = value;
}
{coderay}

How it looks when we create a rock-like robot in the createMainNode method and update its internal states in the updateMainNode method could be found in /tutorials/rock_tutorial/viz.


More than one Type
-----------

If you want to have more than one type to represent the internal state of your plugin you can inherit additionally from VizPluginAddType<SecondType>.
{coderay:: c++}
namespace vizkit
{
    class RockVisualization
        : public vizkit::VizPlugin<base::Pose>
        , public vizkit::VizPluginAddType<int>
        , boost::noncopyable
    {
    public:
        RockVisualization();
        ~RockVisualization();

    protected:
        virtual osg::ref_ptr<osg::Node> createMainNode();
        virtual void updateMainNode(osg::Node* node);
        virtual void updateDataIntern(base::Pose const& plan);
        virtual void updateDataIntern(int const& value);
        
    private:
        struct Data;
        Data* p;
    };
}
{coderay}
Then of course you have to add the method updateDataIntern with the new type as parameter too.

This way you can add various more types.
