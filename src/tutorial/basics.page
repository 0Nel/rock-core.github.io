---
title: Basics
sort_info: 100
---

Abstract
--------------

This tutorial will give you some handson experience on:

 * how to create libraries in ROCK
 * how to embed them into the build system of ROCK called autoproj
 * how to model an Orocos component and embed a library
 * how to run a component and configure it
 * how to connect connect and run multiple components

If you don't want to execute the following steps by yourself, the result can also be found in 'tutorials/basics_tutorial'.

Creating libraries
-----------
Before you start developing components, you will need to think about the functionality that is required for your component. This tutorial teaches you how to write a producer and a consumer component, which will pass timestamped messages inbetween each other. For the producer and the consumer we will create a message library, and we will make it depend on the existing package base/types which allows you to create timestamps.

Now, that it is clear what functionality is needed you can start writing the library. 
Note, that ROCK strongly suggests to encapsulate your main functionality in libraries. Thus, your library code remains independent of the actual framework in use, and can be easily reused and maintained separately from any framework that wraps this functionality.

ROCK allows you to create a C++-library from an existing template - this template has been defined by ROCK maintainers and can be found in base/templates). Calling the command 'rock-create-lib' starts a command line dialog to create a library called 'basics_tutorial/message_driver'

{coderay:: sh}
~/dev$ rock-create-lib basics_tutorial/message_driver
{coderay}

Once called the create script a command line dialog is started, that will request basic information to configure the template for you:
{coderay:: sh}
Initialized empty Git repository in /opt/workspace/rock_sprint/basics_tutorial/message_driver/.git/
Do you want to start the configuration of the cmake project: message_driver
Proceed [y|n]
y
------------------------------------------
We require some information to update the manifest.xml
------------------------------------------
Brief package description (Press ENTER when finished):
A message_driver for the basic ROCK tutorial
Long description: 
This is a library that allows message production and message handling for the the basic ROCK tutorial
Author: 
New user
Author email: 
new-user@rock-robotics.org
Url (optional):

Enter your dependencies as a comma separated list. Press ENTER when finished:
base/types
Initialized empty shared Git repository in /opt/workspace/rock_sprint/basics_tutorial/message_driver/.git/
[master (root-commit) 37aa552] Initial commit
8 files changed, 108 insertions(+), 0 deletions(-)
create mode 100644 CMakeLists.txt
create mode 100644 INSTALL
create mode 100644 LICENSE
create mode 100644 README
create mode 100644 manifest.xml
create mode 100644 src/CMakeLists.txt
create mode 100644 src/Dummy.cpp
create mode 100644 src/Dummy.hpp
create mode 100644 src/Main.cpp
create mode 100644 src/dummyproject.pc.in
Done.
{coderay}

The newly created package comes in a ready to run fashion which means that you can build and install it right away using the build tools autoproj.
{coderay:: sh}
amake basics_tutorial/message_driver
{coderay}
or 
{coderay:: sh}
autoproj build basics_tutorial/message_driver
{coderay}

### Adding the required functionality
Yet, the library does not contain message handling capabilities. So, we create a new header Messages.hpp and a new source file Messages.cpp in the src/ folder of the newly created package

### Integration into the build system

Once you created a library in ROCK you have to add it to the build configuration, so that it can be embedded into orogen components. The easiest way to adapt the configuration is by adding the package to the manifest's layout section. Thus, edit autoproj/manifest and add ' - basic_tutorial/producer' to the layout section.
Be aware that you should use the same indentation as the previous line '- rock.toolchain' since the manifest file is parsed as .yaml, and thus relies on proper indentation. 
{coderay:: sh}
package_sets:
  - type: git 
     branch: $ROCK_FLAVOR
     url: $GITORIOUS_ROOT/rock-toolchain/package_set.git
     push_to: $GITORIOUS_PUSH_ROOT/rock-toolchain/package_set.git

# Layout. Note that the rock.base, rock.toolchain and orocos.toolchain sets are 
# imported by other rock sets.
layout:
   - rock.base
   - rock.toolchain
   - basics_tutorial/producer
{coderay}

Creating an orogen component
--------------------------------
While ROCK uses the Orocos Realtime Toolkit (Orocos RTT) to build its components upon, and uses the Orocos generation tool 'orogen' to easily create so-called orogen components. Orogen requires a component specification to generate a skeleton for you, which you can fill with the functionality you require.
This tutorial does not cover all details of Orocos components but refers to the [toolchain documentation of the Orocos Project](http://www.orocos.org/toolchain) for that purpose.

Similar to the creation of a library you start to create an orogen component using the command 'rock-create-orogen'. 

{coderay:: sh}
~/dev$ rock-create-orogen basics_tutorial/orogen/producer
{coderay}

You will see the same configuration dialog as when calling rock-create-lib.

{coderay:: sh}
------------------------------------------
We require some information to update the manifest.xml
------------------------------------------
Brief package description (Press ENTER when finished):
Message producer component
Long description: 
This component will produce simple, timestamped messages                    
Author: 
New user
Author email: 
new-user@rock-robotics.org
Url (optional):

Enter your dependencies as a comma separated list. Press ENTER when finished:
basics_tutorial/message_driver
{coderay}

All orocos components should be created inside a separated folder called 'orogen' placed in the same folder as the libraries. In your case the libraries and the 'orogen' folder are placed in the 'basics_tutorials' folder.

### Define tasks and deployments

The previous command creates a new folder 'basics_tutorial/orogen/producer'. Inside you find two files: manifest.xml and producer.orogen.
The manifest.xml will have been filled with the information you provided already, but you when you need to add additional dependencies to libraries or orocos components you will have to edit the file directly. Since you want to use your newly created library, check that your library has been added as dependency.
{coderay:: xml}
  <depend package="basics_tutorial/message_driver" />
{coderay}

The producer.orogen is the specification file of the your new orogen component, and allows you to define Orocos tasks and deployments. 
The goal is to create a component which produces messages at a rate of 1 Hz, so the component only requires an output port for messages. 
{coderay:: ruby}
name "producer"

using_library "message_driver"
import_types_from "message_driver/Message.hpp"

task_context "MessageProducerTask" do
  output_port "messages", "basics_tutorial/message"
end

deployment "producer_deployment"
  task("producer", "MessageProducerTask").
      periodic(1)
end
{coderay}

The specification contains a number of statement with the following meaning:
 * name: defines the name of the component, which is required for identification of the component
 * using_library: tells orogen that this component requires, i.e. needs to link against the 'producer' library
 * import_types_from: tells orogen that use a certain type, that is specified in the file following this statement
 * task_context: everything within this block defines an Orocos task context model, including what input and output ports are required
 * deployment: using the task_context model specified in the previous block, a deployment is generated using the model, here: a task named 'producer' is created of model "MessageProducerTask", additional properties can be specified, such as the frequency of calling the so-called updateHook of the task, here: 1 second

The MessageProducerTask has an output port called 'messages' of type basics_tutorial/message. This type is initially unknown to the component, but it can be found in the 'Message.hpp' header of the 'message_driver' library. the using_library statement tells orogen only to look for a library of the given name and link it to any deployment. 
In order to make types known to your component so that you can use them in the specification, you have to do this explicitly with the 'import_types_from' statement.

### 

### Integration into the build system
Again, you should add you component to the build system by adding the package to autproj/manifest's layout section:
{coderay:: sh}
package_sets:
  - type: git 
    branch: $ROCK_FLAVOR
    url: $GITORIOUS_ROOT/rock-toolchain/package_set.git
    push_to: $GITORIOUS_PUSH_ROOT/rock-toolchain/package_set.git

# Layout. Note that the rock.base, rock.toolchain and orocos.toolchain sets are 
# imported by other rock sets.
layout:
  - rock.base
  - rock.toolchain
  - basics_tutorial/message_driver
  - basic_tutorial/orogen/producer
{coderay}

After adding it to the build system you can call autoproj build.

{coderay:: sh}
autoproj build .
{coderay}

If you get an error here, you most likely have a syntax error, then please compare your files with the files in 'tutorials/basics_tutorial'.

### Writing the task
Now, that you have created the orogen component you still have to embedd the functionality that message_driver provides, in order to achieve a proper message producing component. 
With the execution of orogen command several new files have been created. For now, we only need to care about the files in the tasks subfolder and are ignoring the templates folder for a moment. 
Within the tasks folder you will find two files: 'MessageProducerTask.hpp' and 'MessageProcuderTask.cpp'. They contain the skeleton for the Orocos component that has been created. Within 'MessageProcuderTask.hpp' you will find several commented so-called hook methods, and you have to uncomment the methods you want to define in your task. For this tutorial you uncomment updateHook, startHook and cleanupHook.
(More information about this methods could be found [here](../orogen/task_states.html))

To add the message_driver functionality add a forward declaration for message_driver and add a message_driver::MessageDriver member to the MessageProducerTask.hpp:
{coderay:: c++}
namespace message_driver {
    class MessageDriver;
}

namespace producer {
    class MessageProducerTask : public MessageProducerTaskBase
    {   
        friend class MessageProducerTaskBase;
    protected:
        message_driver::MessageDriver* mpMessageDriver;
...
{coderay}

Also add the following statements to the startHook, updateHook, and cleanupHook (make sure they are uncommented in the source and(!) the header file):
At startup the message driver will be created. 
{coderay:: c++}
bool MessageProducerTask::startHook()
{
    if (! MessageProducerTaskBase::startHook())
        return false;
    
    mpMessageDriver = new message_driver::MessageDriver();

    return true;
}
{coderay}

Within the update hook the messages port is accessed, which is identified by the name given in the specification and an '_' prefix. Since you specified the type for this port a 'message_driver::Message' can be written to the port. This update port is triggered at the rate that you specified in the the deployment section of the .orogen file.
{coderay:: c++}
void MessageProducerTask::updateHook()
{
    MessageProducerTaskBase::updateHook();

    message_driver::Message msg = mpMessageDriver->createMessage();
    _messages.write(msg);
}
{coderay}

Put everything that needs to be cleanup after a component failure or shutdown into the cleanupHook. Here, delete the instance of MessageDriver.
{coderay:: c++}
void MessageProducerTask::cleanupHook()
{
    MessageProducerTaskBase::cleanupHook();

    if(mpMessageDriver)
    {
        delete mpMessageDriver;
        mpMessageDriver = 0;
    }
}
{coderay}

To build you first component call:
{coderay:: sh}
amake basics_tutorial/orogen/producer
{coderay}


Run it
-----------

Now, that you have a component ready to run, but probably want to see it running. ROCK offers a ruby scripting interface for that purpose. 
So create a subfolder scripts in the producer componentn and create a file start.rb.

{coderay:: ruby}
require 'orocos'
require 'readline'
include Orocos

## Initialize orocos ##
Orocos.initialize

## Execute the deployment 'producer_deployment' ##
Orocos.run 'producer_deployment' do

## Get a the task context that is started with this deployment##
producer = TaskContext.get 'producer'

## Start the tasks ##
producer.start

reader = producer.messages.reader

while true
    if msg = reader.read
	puts msg
    end

    sleep 0.1
end
{coderay}

This scripts start the process for the deployment 'producer_deployment'. Once the producer_deployment has been created, the task can be accessed using 'TaskContext.get'. Having the reference to the task context allows you to explicitly start the task.

