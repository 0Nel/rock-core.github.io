---
title: Connecting
sort_info: 130
---

Abstract 
-----------------------

* how to connect multiple components [doc](../runtime/ports.html)

Create a consumer component
-----------------------------

Now, it is you task to create a consumer component. Remember the steps:
 * use rock-create-orogen to create your component
 * check for any required dependencies and verify the manifest.xml
 * add your component to the build configuration, i.e. to autoproj/manifest
 * adapt the orogen specification

The component should allow to receive messages on an input port, and call the updateHook only when it receives a message. The specification should looks as follows: 

{coderay:: ruby}
task_context "Task" do
   input_port "messages", "message_driver/Message"

   port_driven "messages"
end


deployment "message_consumer_deployment" do
    task("message_consumer", "Task")
end
{coderay}
The 'port_driven' statement allows you to specify ports, where incoming data triggers a call to the updateHook of the task ( more details in the [documentation](../orogen/triggering/ports.html)).
Implement the updateHook, so that it print any incoming message.
{coderay:: c++}
void Task::updateHook()
{
    TaskBase::updateHook();
    
    message_driver::Message message;
    _messages.read(message);

    mpMessageDriver->printMessage(message);
}
{coderay}

Build your component with 'amake'.


Connecting multiple components
------------------------------

By now, you have designed a component that produces message and a component that consumes message. To connect them, you again can use the Ruby scripting interface. Create a file start.rb in your consumer component's script folder (you will have to create the folder first). 

{coderay:: ruby}
require 'orocos'
require 'readline'

include Orocos
Orocos.initialize


Orocos.run 'message_producer_deployment', 'consumer_deployment' do  

     message_producer = TaskContext.get 'message_producer'
     consumer = TaskContext.get 'consumer'

     message_producer.configure
     message_producer.start

     consumer.start

     message_producer.messages.connect_to consumer.messages

     Readline::readline("Press ENTER to exit\n") do
     end 
end
{coderay}

The call to 'connect_to' for an output port allows you to connect it with an input port. By default a data connection is created, but you can also specify the type of your connection explicitly. Check the [documentation](../runtime/ports.html) for more details on that topic. 

### Run it

Run your ruby script
{coderay:: c++}
ruby start.rb
{coderay}

If everything has been done correctly, you will eventually see the consumer printing messages to the console, in the periodicity you set on the message producer: 

{coderay:: c++}
[20110803-10:59:55:068] Message from MessageDriver
[20110803-10:59:56:068] Message from MessageDriver
[20110803-10:59:57:068] Message from MessageDriver
[20110803-10:59:58:068] Message from MessageDriver
{coderay}

Summary
---------------------
In this tutorial you have learned to: 

 * create a component that is triggered upon receiving incoming data, i.e. you know now how to design a port/data driven component
 * run two components using a single ruby script
 * connect two components by connecting an output and an input port with a default data connection



