---
title: Setting Up Data Logging
sort_info: 100
---

People that use robotic system know that logging is the root of most of the
work. Why ? Because a robot software layer generates a lot of data and that
usually you want to analyze that data post-mortem.

This page presents how to save the data from ports into log files. The [next
page](will present how to read that data to analyze it).

The setup
---------
Logging in oroGen projects is handled through two things:

 * a marshaller that is generated by orogen,
 * a generic, high-performance, logging component that is able to log
   any type that orogen understands.
   * finally, a command line tool to export the generated data, and a Ruby library that allows to manipulate the data in log files.

The two most important features of that logging setup are that (i) it is very low overhead (see below) and (ii) generated log files are self-contained. That means that, once a log file has been generated, it can be read and analyzed even though you know absolutely nothing about the software that generated it.

Making oroGen deployments logging-ready
---------------------------------------
The only step needed to make an oroGen deployment "ready to log" is to add an add_default_logger statement in your deployment. For instance:

{coderay:: ruby}
deployment "test_imu" do
  task "imu", "imu::Task"
  add_default_logger
end
{coderay}

Logging all output ports using Orocos.rb
----------------------------------------
If you are starting up your system using orocos.rb (why should you not ;-)), the
simplest way to start logging is to add

{coderay:: ruby}
Orocos.log_all_ports
{coderay}

after all the deployments have been started. It will setup each deployment's
logger to log all output ports of the deployment. Logging data is generated in a
"name._index_.log" file, where name is the deployment's name and _index_ is
incremented to avoid overwriting old log files (i.e. name.0.log by default, but
if name.0.log exists, then name.1.log and so on). A complete example with the
test_imu deployment above would be

{coderay:: ruby}
# Start the test_imu deployment
Orocos.run "test_imu" do |p|
  # Set up logging
  Orocos.log_all_ports

  # Start the IMU task
  task = p.task 'imu'
  task.start

  # Poll the task's states every 100 ms and report if one of them stops
  Orocos.survey(0.1)
end
{coderay}

If you don't want to log some types, then use the exclude_types option. That
option takes a regular expression, all ports whose type matches that regex will
not be logged. For instance:

{coderay:: ruby}
Orocos.log_all_ports :exclude_types => /can\/Message/
{coderay}

will log all ports whose typename does not contain "can/Message"

Hand-made logging using Orocos.rb
---------------------------------
The logfile format the logger is using is multiplexing data streams into a
single file. The logger component simply associates each of its input ports to a
stream in the file, and will save the data coming on one of the input port in
the associated stream.

So, to log a port, you basically need to

 * ask the logger to create a new stream and the associated port by using the
   createPort method.
 * connect the output port you want to log to that new logger port.

With orocos.rb, this is done with:

{coderay:: ruby}
logger = p.task 'Logger'
imu     = p.task 'imu'

logger.file = "logfile.log"

# Add a stream in the log file named "orientations".
# This also creates a port with the same name.
logger.createPort 'orientations', '/base/Orientation3D'
# And log the IMU output
imu.orientations.connect_to(logger.orientations)
{coderay}

