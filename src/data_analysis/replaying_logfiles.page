---
title: Replay Log Data
sort_info: 300
---

Log::Replay is a ruby library which is able to load log files and provides
methods to access, filter and replay the data to ruby or RTT components.
It uses Pocolog to load the log data and emulates on top the ruby interface 
of RTT components during replay.

Features:
---------
  * loading and aligning logfiles
  * time synchronous replay
  * step by step replay
  * seeking
  * user-specific log data filter
  * same interface like Orocos::TaskContext

Usage:
------
The replayed log files are specified during initialization of Log::Replay 
or with the method load after initialization.

{coderay:: ruby}
replay = Log::Replay.open(file0,folder0,...)
replay.load(folder1)
replay.load(file1)
{coderay}

So far it is not possible to load multiple log files from the same component at the
same time because of overlapping names.
{: .warning}

After loading the log files the logged RTT components are modeled as Log::TaskContext which can be
accessed by the names of the logged RTT components.

{coderay:: ruby}
task1 = replay.camera           #if a task named camera was logged to
                                #loaded log files
task2 = replay.task('camera')   #same as replay.camera
{coderay}

The ports of the Log::TaskContext can be used the same way RTT component ports are used.

{coderay:: ruby}
output_port = replay.camera.frame     #accessing the port frame
{coderay}

They are accessed through a reader or direct via the method read. 
The only different between both ways is the method read will always returns the last replayed 
data sample but in contrast the behavior of the reader depends on the applied connection policy.

{coderay:: ruby}
reader = output_port.reader :type => :data
puts reader.read                      #no different between both
puts output_port.read                 #reads
{coderay}

{coderay:: ruby}
reader = output_port.reader :type => :buffer,:size => 1
puts reader.read                      #=> last replayed sample
puts reader.read                      #=> nil
puts output_port.read                 #=> last replayed sample
puts output_port.read                 #=> last replayed sample
{coderay}

To connect Log::OutputPort(s) to RTT component ports the connect_to method is used.

{coderay:: ruby}
replay.camera.frame.connect_to rtt_task.frame
{coderay}

An other way to set up the connection to RTT components is the auto 
connect method, which requires for each input port an unique
Log::OutputPort which has the same name and type. 
To help Log::Replay by finding the right port pair a port mapping 
can be provided.

{coderay:: ruby}
replay.connect_to rtt_task                      #auto connect
{coderay}

{coderay:: ruby}
replay.connect_to rtt_task, :frame => :iframe   #port mapping
{coderay}

The replay is started either in auto mode or step by step. By default
the auto mode is running as fast as possible.

Note: All code blocks for ports and readers are applied as filers!!!
{: .warning}

{coderay:: ruby}
replay.run              #replay all logged data as fast as possible
{coderay}

{coderay:: ruby}
replay.run(true,1)      #replay as fast as the date were recorded
{coderay}

{coderay:: ruby}
replay.step             #replay one data sample
{coderay}

Only ports are replayed which are connected to RTT Components, 
a reader or filter was created for or are marked explicitly.
{: .warning}

{coderay:: ruby}
replay.camera.frame.tracked = true      #mark port to be replayed
{coderay}

Example: Loading and accessing log data:
---------------------------------------
{coderay:: ruby}
#!/usr/bin/env ruby

require 'orocos/log'
include Orocos

replay = Log::Replay.open('camera.0.log')
replay.camera.frame do |frame|
  puts frame.time
end
replay.run                      #replay as fast as possible
{coderay}

Example: Loading and replaying log data
---------------------------------------
{coderay:: ruby}
#!/usr/bin/env ruby

require 'orocos/log'
include Orocos

replay = Log::Replay.open('camera.0.log')

Orocos.run 'deployment_x' do
  task_x = TaskContext.get('task_x')
  replay.connect_to task_x                    #auto connect
  task_x.start
  replay.run
end
{coderay}

Example: Filtering log data
---------------------------
{coderay:: ruby}
#!/usr/bin/env ruby

require 'orocos/log'
include Orocos

replay = Log::Replay.open('camera.0.log')

Orocos.run 'deployment_x' do
  task_x = TaskContext.get('task_x')
  replay.connect_to task_x 

  #the filter is applied on each frame
  #before it is written to ports or readers
  
  replay.camera.frame.filter = Proc.new do |frame|
    frame.time = Time.now
    frame
  end

  task_x.start
  replay.run
end
{coderay}

Example: Advanced
---------------------------
{coderay:: ruby}
#!/usr/bin/env ruby

require 'orocos/log'
include Orocos

replay = Log::Replay.open('camera.0.log','sonar.0.log')

Orocos.run 'deployment_x','deployment_y' do
  task_x = TaskContext.get('task_x')
  task_y = TaskContext.get('task_y')
  replay.connect_to task_x  
  replay.connect_to task_y, "sonar.frame" => "iframe"  #port mapping
  
  #get a reader 
  #Be careful. Here is a filter applied on the reader
  #if the original frame is changed in the filter all 
  #readers for the same frame which are created after this 
  #reader are affected as well.
  reader = replay.camera.frame.reader do |frame|
    puts frame.time
    frame
  end

  #display all ports of type /base/samples/frame/Frame
  ports = replay.find_all_ports('/base/samples/frame/Frame')
  ports.each do |port|
    port.pp
  end

  task_x.start
  task_y.start

  replay.step(false)                    #replay one step
  replay.step(false)                    #replay one step

  puts replay.camera.frame.read.time    #display current 
                                        #frame time stamp
  puts reader.read.time                 #should be the same
  replay.rewind                         #rewind log data

  #the code block is called for each message on all
  #ports
  replay.run do |port,data|
    puts data.time if port.name == 'frame'
  do
end
{coderay}
