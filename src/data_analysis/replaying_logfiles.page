---
title: Replay Log Data
sort_info: 300
---

Orocos::Log::Replay is a ruby class which eases common tasks on log files. It
provides methods to access, filter and replay the data inside Ruby scripts, or
in destination of RTT
components. 

Features:
---------
  * loads log files
  * time synchronous replay
  * step by step replay
  * seeking
  * user-specific log data filter
  * in the Ruby script, log files behave like instances Orocos::TaskContext

This functionality needs the orocos.rb package to be installed, which is
contained in the Rock toolchain.
{: .warning}

See [this page](/runtime/ruby_and_types.html) for a description of the mapping
from the C++ types in Ruby 
{: .notes}

Usage:
-e----
The replayed log files can either be specified when initializing a
Orocos::Log::Replay object, or later on by using the #load method.

{coderay:: ruby}
replay = Log::Replay.open(file0,folder0,...)
replay.load(folder1)
replay.load(file1)
{coderay}

So far it is not possible to load multiple log files from the same component at the
same time because of overlapping names.
{: .warning}

After loading, the class offers an interface to log files that mimicks the
Orocos::TaskContext API. This assumes that the log streams are called
'task_name.port_name' -- which is the case if you are using the
Orocos.log_all_ports setup method. 

To access all streams from a particular task context, do

{coderay:: ruby}
task1 = replay.camera
task2 = replay.task('camera')
{coderay}

The equivalent call for live components is Orocos::TaskContext.get

Then, each log stream is mapped to a port-like object:

{coderay:: ruby}
# Accesses the data logged from the port 'frame' of the task 'camera'
output_port = replay.camera.frame
{coderay}

They are accessed through a reader or direct via the method read. 
The only different between both ways is the method read will always returns the last replayed 
data sample but in contrast the behavior of the reader depends on the applied connection policy.

{coderay:: ruby}
reader = output_port.reader :type => :data
puts reader.read                      #no different between both
puts output_port.read                 #reads
{coderay}

{coderay:: ruby}
reader = output_port.reader :type => :buffer,:size => 1
puts reader.read                      #=> last replayed sample
puts reader.read                      #=> nil
puts output_port.read                 #=> last replayed sample
puts output_port.read                 #=> last replayed sample
{coderay}

If you wish to feed logged data to a running RTT component, you can use the
normal connect_to method:

{coderay:: ruby}
replay.camera.frame.connect_to rtt_task.frame
{coderay}

If you wish to transform the data before it gets fed to the task, you can
specify a filtering block:

{coderay:: ruby}
replay.camera.frame.connect_to rtt_task.frame do |sample|
  # the sample gets transformed here
  sample # return the modified value
end
{coderay}

Moreover, to make simple cases straightforward, the replay class can autoconnect
log streams to component ports. For each port of
the target task, an equivalent port (same name and same type) is searched for in
the logged data. If the name differs, a name mapping can be provided.

{coderay:: ruby}
replay.connect_to rtt_task                      #auto connect
{coderay}

{coderay:: ruby}
# Connects matching ports between the log data and a running RTT component
# When looking for matching names, 'frame' (on the logged side) will be replaced
by "iframe" (on the component side).
replay.connect_to rtt_task, :frame => :iframe
{coderay}

Once the replay network is properly set up, you start replaying by calling #run.

{coderay:: ruby}
replay.run         # replay all logged data as fast as possible
replay.run(true,1) # replay as fast as the date were recorded
replay.step        # replay one data sample
{coderay}

<div class="warning">
Only ports are replayed which are connected to RTT components, for which a
reader has been created or a filter was specified. If you want to specify that
one particular stream should be replayed, set its #tracked property to true:
{coderay:: ruby}
replay.camera.frame.tracked = true # Forces the log stream to be replayed
{coderay}
</div>

Example: Loading and accessing log data:
---------------------------------------
{coderay:: ruby}
#!/usr/bin/env ruby

require 'orocos/log'
include Orocos

replay = Log::Replay.open('camera.0.log')
replay.camera.frame do |frame|
  puts frame.time
end
replay.run                      #replay as fast as possible
{coderay}

Example: Loading and replaying log data
---------------------------------------
{coderay:: ruby}
#!/usr/bin/env ruby

require 'orocos/log'
include Orocos

replay = Log::Replay.open('camera.0.log')

Orocos.run 'deployment_x' do
  task_x = TaskContext.get('task_x')
  replay.connect_to task_x                    #auto connect
  task_x.start
  replay.run
end
{coderay}

Example: Filtering log data
---------------------------
{coderay:: ruby}
#!/usr/bin/env ruby

require 'orocos/log'
include Orocos

replay = Log::Replay.open('camera.0.log')

Orocos.run 'deployment_x' do
  task_x = TaskContext.get('task_x')
  replay.connect_to task_x 

  #the filter is applied on each frame
  #before it is written to ports or readers
  
  replay.camera.frame.filter = Proc.new do |frame|
    frame.time = Time.now
    frame
  end

  task_x.start
  replay.run
end
{coderay}

Example: Advanced
---------------------------
{coderay:: ruby}
#!/usr/bin/env ruby

require 'orocos/log'
include Orocos

replay = Log::Replay.open('camera.0.log','sonar.0.log')

Orocos.run 'deployment_x','deployment_y' do
  task_x = TaskContext.get('task_x')
  task_y = TaskContext.get('task_y')
  replay.connect_to task_x  
  replay.connect_to task_y, "sonar.frame" => "iframe"  #port mapping
  
  #get a reader 
  #Be careful. Here is a filter applied on the reader
  #if the original frame is changed in the filter all 
  #readers for the same frame which are created after this 
  #reader are affected as well.
  reader = replay.camera.frame.reader do |frame|
    puts frame.time
    frame
  end

  #display all ports of type /base/samples/frame/Frame
  ports = replay.find_all_ports('/base/samples/frame/Frame')
  ports.each do |port|
    port.pp
  end

  task_x.start
  task_y.start

  replay.step(false)                    #replay one step
  replay.step(false)                    #replay one step

  puts replay.camera.frame.read.time    #display current 
                                        #frame time stamp
  puts reader.read.time                 #should be the same
  replay.rewind                         #rewind log data

  #the code block is called for each message on all
  #ports
  replay.run do |port,data|
    puts data.time if port.name == 'frame'
  do
end
{coderay}
